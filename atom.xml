<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr·Zh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-17T15:19:20.618Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr·Zh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>try-catch-finally是如何执行的</title>
    <link href="http://yoursite.com/2020/05/17/try-catch-finally%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>http://yoursite.com/2020/05/17/try-catch-finally是如何执行的/</id>
    <published>2020-05-17T14:53:17.000Z</published>
    <updated>2020-05-17T15:19:20.618Z</updated>
    
    <content type="html"><![CDATA[<p>根据 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html" target="_blank" rel="noopener">JDK Tutorial</a> 的描述，除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，finally 中的逻辑始终会执行。因此 finally 关键字常被用于释放资源，防止程序出现异常时出现资源泄露。本文主要探讨其在 JVM 层面的实现原理，以及 synchronized 关键字在类似场景的处理手段。首先来看一段简单的 try-finally 代码</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithTryFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"try"</span>);</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"finally"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其对应字节码如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=2, args_size=1</span><br><span class="line">    0: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    3: ldc            #6                  // String try</span><br><span class="line">    5: invokevirtual  #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    8: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: ldc           #8                  // String finally</span><br><span class="line">    13: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    16: goto          30</span><br><span class="line">    19: astore_1</span><br><span class="line">    20: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    23: ldc           #8                  // String finally</span><br><span class="line">    25: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    28: aload_1</span><br><span class="line">    29: athrow</span><br><span class="line">    30: return</span><br><span class="line">Exception table:</span><br><span class="line">    from    to  target type</span><br><span class="line">       0     8    19   any</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>0 - 8 行是 try 中的语句</li><li>8 - 13，20 - 25 行是 finally 中的语句</li></ul><p>那么为什么 finally 语句会出现两遍呢？其实这两次分别对应程序正常执行和异常执行的情况，8 - 13 行是在正常执行时会执行的 finally 语句，执行完成后通过 16 行的 <code>goto</code> 指令跳转到 <code>return</code> 指令返回；而 20 - 25 行则是由异常表（Exception table）进行触发，可以看到异常表会捕捉 0 - 8 行（不包含第8行）的字节码出现的任意异常，并且跳转至 19 行开始执行 finally 语句，最后通过 29 行 <code>athrow</code> 指令向上抛出异常。</p><p>那么如果增加 catch 呢，会有什么区别吗？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithTryCatchFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="hljs-string">"try"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="hljs-string">"catch"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="hljs-string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=3, args_size=1</span><br><span class="line">    0: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    3: ldc            #6                  // String try</span><br><span class="line">    5: invokevirtual  #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    8: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: ldc           #8                  // String finally</span><br><span class="line">    13: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    16: goto          50</span><br><span class="line">    19: astore_1</span><br><span class="line">    20: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    23: ldc           #10                 // String catch</span><br><span class="line">    25: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    28: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    31: ldc           #8                  // String finally</span><br><span class="line">    33: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    36: goto          50</span><br><span class="line">    39: astore_2</span><br><span class="line">    40: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    43: ldc           #8                  // String finally</span><br><span class="line">    45: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    48: aload_2</span><br><span class="line">    49: athrow</span><br><span class="line">    50: return</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     8    19   Class java/lang/Exception</span><br><span class="line">            0     8    39   any</span><br><span class="line">            19    28   39   any</span><br></pre></td></tr></table></figure><ul><li>0 - 5 行是 try 中的语句</li><li>20 - 25 行是 catch 中的语句</li><li>8 - 13,   28 - 33, 40 - 45 行是 finally 中的语句</li></ul><p>大体上和之前逻辑相同，只不过这里 finally 中的语句又赋予了 catch 一遍，所以被 catch 后也能执行 finally 语句。根据上面两个例子，我们也验证了 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html" target="_blank" rel="noopener">JDK Tutorial</a> 的描述，即<strong>除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，finally 中的逻辑始终会执行。</strong></p><h1 id="包含控制语句的-try-finally"><a href="#包含控制语句的-try-finally" class="headerlink" title="包含控制语句的 try-finally"></a>包含控制语句的 try-finally</h1><p>不知道大家有没有注意到，finally 语句的字节码前后总会出现 <code>astore</code>/<code>aload</code> 这样成对的指令，它们的作用是什么呢？根据指令本身的含义，我们可以知道</p><ul><li><code>astore</code> 是将操作数栈顶存储到局部变量表</li><li><code>aload</code> 是将局部变量加载到操作数栈，以便后续 <code>ireturn</code> 指令将栈顶的值返回给方法调用者</li></ul><p>它在我们分析包含控制转移语句（比如 return）的 try-catch-finally 有着至关重要的作用。举一个包含控制语句的 try-finally 的例子</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testWithTryReturnFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output: 0</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack=1, locals=4, args_size=1</span><br><span class="line">    0: iconst_0</span><br><span class="line">    1: istore_1</span><br><span class="line">    2: iload_1</span><br><span class="line">    3: istore_2</span><br><span class="line">    4: iinc           1, 1</span><br><span class="line">    7: iload_2</span><br><span class="line">    8: ireturn</span><br><span class="line">    9: astore_3</span><br><span class="line">    10: iinc          1, 1</span><br><span class="line">    13: aload_3</span><br><span class="line">    14: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     4     9   any</span><br></pre></td></tr></table></figure><ul><li>0：将常量 0 加载到操作数栈</li><li>1：将栈顶 int 数值存入第 2 局部变量（其中由于这里是方法调用，第 1 局部变量被调用方执行 <code>invokevirtual</code> 指令将对象的引用隐式的传进来了），此时第 2 局部变量的值为 0</li><li>2：将第 2 局部变量（0）的值加载到操作数栈</li><li>3：<strong>将栈顶的值存入第 3 局部变量（这里开始了 finally 的逻辑），这里相当于对 try 中的结果做了一次备份</strong>，此时第 3 局部变量的值为 0</li><li>4：将第 2 局部变量（0）的值加 1</li><li>7：<strong>加载第 3 局部变量的值到操作数栈（finally 语句结束），这里取出的是之前备份的值</strong></li><li>8：返回栈顶元素，此时由于栈顶是执行 finally 前备份的值，所以值为 0 </li><li>9：将栈顶的异常对象存入第 4 局部变量（进入到该阶段的指令一般由异常表触发，所以此时栈顶是异常对象）</li><li>10：将第 2 局部变量（0）的值加 1</li><li>13：将第 4 局部变量（异常对象）加载到操作数栈</li><li>14：将栈顶（异常对象）抛出</li></ul><p>上述解释将对于最终返回结果比较重要的 3 和 7 指令进行了加粗，它展示了<strong>虽然 finally 语句会执行，但是它的计算结果不一定会影响到返回值</strong>，所以这里是容易被误解的地方，平常要避免这样使用。</p><p>那么是不是说放在 finally 中的计算都不会影响到 return 的结果呢？那当然不是，比如 return 不在 try 中，那么自然是会影响的，而如果 return 如果在 finally 中，又是什么样一种结果呢？比如：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testWithTryReturnFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output: 1</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack=1, locals=4, args_size=1</span><br><span class="line">    0: iconst_0</span><br><span class="line">    1: istore_1</span><br><span class="line">    2: iload_1</span><br><span class="line">    3: istore_2</span><br><span class="line">    4: iinc           1, 1</span><br><span class="line">    7: iload_1</span><br><span class="line">    8: ireturn</span><br><span class="line">    9: astore_3</span><br><span class="line">    10: iinc          1, 1</span><br><span class="line">    13: iload_1</span><br><span class="line">    14: ireturn</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     4     9   any</span><br></pre></td></tr></table></figure><p>看 7 和 13 指令，这里和刚才的有比较大的区别，它们用于返回的 iload_1 是原本的值（非备份），因此返回的结果是 1。当然还有一个更重要的区别是：<strong>在 finally 中使用了 return 后丢失了 <code>athrow</code>，这意味着 try 中抛出的异常会丢失</strong>（finally 中抛出的异常仍然会继续抛出），这是一个比较严重的问题。这里使用一个例子演示一下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testWithTryReturnFinallyException</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output: 1</span><br></pre></td></tr></table></figure><p>上述代码并不会抛出异常，而是返回 1。所以 finally 中要避免使用 return，否则会得到意想不到的结果。经过上述几个例子，现在对 try-catch-finally 做了一个总结：</p><ol><li>除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，否则 finally 中的逻辑始终会执行</li><li>finally 语句块会在 try block 的控制转移语句（如 return）之前执行，但不会影响最终返回的结果，除非 finally 抛出了异常或使用了 return 等控制转移语句</li><li>避免在 finally 中使用 return，这会导致 try block 中的异常被丢失</li></ol><h1 id="synchronized-如何保证始终执行-monitorexit"><a href="#synchronized-如何保证始终执行-monitorexit" class="headerlink" title="synchronized 如何保证始终执行 monitorexit"></a>synchronized 如何保证始终执行 monitorexit</h1><p>我们都知道 synchronized 对于同步语句块会使用 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令，那么它们如何保证退出时始终执行 <code>monitorexit</code> 呢？答案其实和 finally 类似，我们举个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithSync</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"sync"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=3, args_size=1</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: dup</span><br><span class="line">    2: astore_1</span><br><span class="line">    3: monitorenter</span><br><span class="line">    4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    7: ldc           #6                  // String sync</span><br><span class="line">    9: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    12: aload_1</span><br><span class="line">    13: monitorexit</span><br><span class="line">    14: goto          22</span><br><span class="line">    17: astore_2</span><br><span class="line">    18: aload_1</span><br><span class="line">    19: monitorexit</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: athrow</span><br><span class="line">    22: return</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            4    14    17   any</span><br><span class="line">            17   20    17   any</span><br></pre></td></tr></table></figure><p>根据异常表可知即使同步块内容出现异常（4 - 14），仍然会跳转至 17 完成 <code>monitorexit</code> 的执行，这不就是 finally 的执行过程吗。但是这里相对 finally 有一个特殊的地方就是异常表对 17 - 20 行出现异常的情况进行了无限循环，而 17 - 20 行实际上就是执行 <code>monitorexit</code> 的过程，也就是说一旦 <code>monitorexit</code> 抛出异常，那么线程就会进入无限循环。根据 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener">The Java Virtual Machine Instruction Set</a> 介绍，<code>monitorexit</code> 会存在抛出 NullPointerException 和 IllegalMonitorStateException 两种异常，这就证明确实会存在无限循环的可能性。</p><blockquote><p>If <em>objectref</em> is <code>null</code>, <em>monitorexit</em> throws a <code>NullPointerException</code>.</p><p>Otherwise, if the thread that executes <em>monitorexit</em> is not the owner of the monitor associated with the instance referenced by <em>objectref</em>, <em>monitorexit</em> throws an <code>IllegalMonitorStateException</code>.</p><p>Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">§2.11.10</a> and if the second of those rules is violated by the execution of this <em>monitorexit</em> instruction, then <em>monitorexit</em> throws an <code>IllegalMonitorStateException</code>.</p></blockquote><p>那么这合理吗？在 2002 年就有一个 Bug 描述 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4414101" target="_blank" rel="noopener">JDK-4414101 : synchronized statement generates catch around the monitorexit</a> 被提交，但最终被标记为非 bug。回答者认为无限循环是一个正确的行为，因为同步代码块的退出始终需要伴随着 monitor 的释放，一旦做不到这一点那么将线程放入无限循环中比执行其他操作更正确</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JDK Tutorial&lt;/a&gt; 的描述，除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，finally 中的逻辑始终会执行。因此 finally 关键字常被用于释放资源，防止程序出现异常时出现资源泄露。本文主要探讨其在 JVM 层面的实现原理，以及 synchronized 关键字在类似场景的处理手段。首先来看一段简单的 try-finally 代码&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testWithTryFinally&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;try&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;finally&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的避免空指针</title>
    <link href="http://yoursite.com/2020/02/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/02/05/如何优雅的避免空指针/</id>
    <published>2020-02-05T14:07:27.000Z</published>
    <updated>2020-02-06T05:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NPESolution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withIf</span><span class="hljs-params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(person != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withSpringAssert</span><span class="hljs-params">(Person person)</span></span>&#123;</span><br><span class="line">        Assert.isTrue(person != <span class="hljs-keyword">null</span>, <span class="hljs-string">"person must be not null."</span>);</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withOptional</span><span class="hljs-params">(Person person)</span></span>&#123;</span><br><span class="line">        Optional&lt;Person&gt; personOptional = Optional.ofNullable(person);</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withJsr305Annotation</span><span class="hljs-params">(@Nonnull Person person)</span></span>&#123;</span><br><span class="line">        Optional&lt;Person&gt; personOptional = Optional.of(person);</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是我在日常用于避免空指针（<code>NPE</code>）的常用方式，很长时间内我都热衷于断言（<code>Assert</code>）这类防御性编程方式，防御性编程可以有效的保证方法的输入条件，并在毫无意义的边界情况能够给出有效的提示，何乐而不为呢？事实上防御性编程也确实是一种非常推荐的方式，并且其在 Spring 源码中随处可见。而 JDK8 的 <code>Optional</code> 是否会是一种更优雅的方式呢？亦或许，另有它人？</p><a id="more"></a><p>if 语句是初学者最常使用的处理空指针的方式，直至今日它也在大多数场景被推荐使用。即使是如此简单的方式，其实也可以略微优化。下面是一个使用 if 语句的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(person == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ...;</span><br></pre></td></tr></table></figure><p>在现实业务中我们难以避免地会需要解决分支，<code>if-else</code> 是大多数人常用的方式。但是如果分支内部又产生了分支，我们的代码可读性就会大大的降低，因此这里提到的技巧就是“及时终止”。何谓“及时终止”，简单来说就是通过提前终止代码逻辑来减少嵌套 <code>if-else</code> 的复杂度。优化后的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(person == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">  <span class="hljs-keyword">return</span> ...;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ...</span></span><br><span class="line"><span class="hljs-keyword">return</span> ...;</span><br></pre></td></tr></table></figure><p>既然 if 语句已经能够解决空指针问题，那么为什么 Spring 这类开源项目要使用 <code>Assert</code> 呢？原因在于真实业务场景中，空指针这类的边界条件非常多，并且它很有可能对业务方法的毫无意义，因此使用 <code>Assert</code> 的方式会显得清晰明了，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// org.springframework.validation.beanvalidation.SpringValidatorAdapter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringValidatorAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartValidator</span>, <span class="hljs-title">javax</span>.<span class="hljs-title">validation</span>.<span class="hljs-title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Create a new SpringValidatorAdapter for the given JSR-303 Validator.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetValidator the JSR-303 Validator to wrap</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringValidatorAdapter</span><span class="hljs-params">(javax.validation.Validator targetValidator)</span> </span>&#123;</span><br><span class="line">Assert.notNull(targetValidator, <span class="hljs-string">"Target Validator must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.targetValidator = targetValidator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups) &#123;</span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetValidator != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No target Validator set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetValidator.validate(object, groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object, String propertyName, Class&lt;?&gt;... groups) &#123;</span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetValidator != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No target Validator set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetValidator.validateProperty(object, propertyName, groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(</span><br><span class="line">Class&lt;T&gt; beanType, String propertyName, Object value, Class&lt;?&gt;... groups) &#123;</span><br><span class="line"></span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetValidator != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No target Validator set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetValidator.validateValue(beanType, propertyName, value, groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 <code>Assert</code> 这类防御性编程方式的缺陷也非常明显，业务逻辑中会存在大量的判空逻辑，通过 <code>Assert</code> 代替 if 语句的方式会使得方法内部存在大量的防御性代码，这并不能提高代码质量，因此 <strong>防御性代码常用于输入参数校验</strong>。而<strong>业务逻辑中的 <code>NPE</code> 解决方案应该是 <code>Optional</code> 类</strong>，构建 <code>Optional</code> 对象的方式通常为 <code>ofNullable</code> 方法或 <code>of</code> 方法，它们的区别在于传入对象是否允许为空</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; personOptional = Optional.ofNullable(person);</span><br><span class="line">Optional&lt;Person&gt; personOptional = Optional.of(person); <span class="hljs-comment">// null is not allowed</span></span><br></pre></td></tr></table></figure><p>我们可以在 <code>Optional</code> 实现类中找到大量 防御性代码 + <code>Optional.of()</code> 组合使用的应用场景，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// java.util.Optional#filter</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate); <span class="hljs-comment">// Assert 类似的效果</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-keyword">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上述的方式，我们可以基本完成一个比较优雅的避免空指针的模式了，并且当我们错误的传入空指针时，编译器（如 idea）会在运行期前及时的提醒我们方法不允许为空。那么这就够了么？还不够。在很多时候，我们会遇到遗留代码或提供三方<code>jar</code> 包，调用方往往会苦于无法确定传入参数是否允许为空，从而不得不研究方法实现。因此更优雅的方式是，我们对外提供的接口（<code>public</code>）可以通过标记注解来对接口进行说明，而此类注解同样能触发编译器的警告。<code>JSR 305</code> 规范已经提供了此类注解，我们只需引入 <code>com.google.code.findbugs:jsr305</code> 的 <code>jar</code> 包，就可以使用 <code>@Nullable，@Nonnull，@CheckForNull</code> 等标记注解了。</p><p>到此我们就实现了优雅避免空指针的方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withSmart</span><span class="hljs-params">(@Nonnull Person person)</span></span>&#123;</span><br><span class="line">    Objects.requireNonNull(person, <span class="hljs-string">"person must be not null."</span>);</span><br><span class="line">    Optional&lt;Person&gt; personOptional = Optional.of(person);</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够为我们带来：</p><ul><li><code>@Nonnull</code>（标志注解）：清晰的对外接口签名，并且能够触发 findBugs 或 idea 对代码运行期前的检查</li><li><code>Objects.requireNonNull</code>（防御性代码）：在触发边界条件时提供有意义的异常警告</li><li><code>Optional</code>：提供优雅的业务逻辑判空实现</li></ul><blockquote><p>由于私有方法不会对外暴露，所以私有方法可以只使用 <code>Optional</code>类来避免 <code>NPE</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NPESolution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withIf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(person != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withSpringAssert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Assert.isTrue(person != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;person must be not null.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withOptional&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Optional&amp;lt;Person&amp;gt; personOptional = Optional.ofNullable(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withJsr305Annotation&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@Nonnull Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Optional&amp;lt;Person&amp;gt; personOptional = Optional.of(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述的代码是我在日常用于避免空指针（&lt;code&gt;NPE&lt;/code&gt;）的常用方式，很长时间内我都热衷于断言（&lt;code&gt;Assert&lt;/code&gt;）这类防御性编程方式，防御性编程可以有效的保证方法的输入条件，并在毫无意义的边界情况能够给出有效的提示，何乐而不为呢？事实上防御性编程也确实是一种非常推荐的方式，并且其在 Spring 源码中随处可见。而 JDK8 的 &lt;code&gt;Optional&lt;/code&gt; 是否会是一种更优雅的方式呢？亦或许，另有它人？&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>HSDB从入门到实战</title>
    <link href="http://yoursite.com/2019/12/06/HSDB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/12/06/HSDB从入门到实战/</id>
    <published>2019-12-06T15:17:42.000Z</published>
    <updated>2020-02-06T05:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HSDB（Hotspot Debugger)</code>，是一款内置于 SA 中的 GUI 调试工具，可用于调试 JVM 运行时数据，从而进行故障排除</p><h2 id="启动HSDB"><a href="#启动HSDB" class="headerlink" title="启动HSDB"></a>启动HSDB</h2><p>检测不同 JDK 版本需要使用不同的 <code>HSDB</code> 版本，否则容易出现无法扫描到对象等莫名其妙的问题</p><ul><li><p><strong>Mac</strong>：JDK7 和 JDK8 均可以采用以下的方式</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo java -cp ,:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure><blockquote><p>事实上经过测试，即使通过 JDK8 自带的 <code>sa-jdi.jar</code> 去扫描对象（<code>scanoops</code>）的时候也会发生扫不到的情况，但可以通过其他手段代替</p></blockquote><p>而 JDK11 的启动方式有些区别</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/bin/jhsdb hsdb</span><br></pre></td></tr></table></figure><blockquote><p>事实上经过测试，该版本启动的 <code>HSDB</code> 会少支持一些指令（比如 <code>mem, whatis</code>），<strong>因此目前不推荐使用该版本</strong></p></blockquote></li><li><p><strong>Windows</strong>: </p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -classpath <span class="hljs-string">"%JAVA_HOME%/lib/sa-jdi.jar"</span> sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure></li></ul><p>其中启动版本可以使用 <code>/usr/libexec/java_home -V</code> 获取</p><blockquote><p>若遇到 Unable to locate an executable at “/Users/xx/.jenv/versions/1.7/bin/jhsdb” (-1) 可通过 <code>Jenv</code> 切换到当前 Jdk 版本即可解决</p></blockquote><a id="more"></a><h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><p><code>HSDB</code> 对 <code>Serial GC</code> 支持的较好，因此 Debug 时增加参数 <code>-XX:+UseSerialGC</code>，Debug 工具可以使用 IDE 或 JDB</p><h2 id="获取应用进程id"><a href="#获取应用进程id" class="headerlink" title="获取应用进程id"></a>获取应用进程id</h2><p>jps 仅查找当前用户的 Java 进程，而不是当前系统中的所有进程</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br></pre></td></tr></table></figure><ul><li>默认<strong>显示 pid </strong>以及 <strong>main 方法对应的 class 名称</strong></li><li>-v：<strong>输出传递给 JVM 的参数</strong></li><li>-l： <strong>输出 main 方法对应的 class 的完整 package 名</strong></li></ul><h2 id="CLHSDB常用指令"><a href="#CLHSDB常用指令" class="headerlink" title="CLHSDB常用指令"></a>CLHSDB常用指令</h2><ul><li><p><code>universe</code>：查看堆空间信息</p></li><li><p><code>scanoops start end [type]</code>：扫描指定空间中的 type 类型及其子类的实例</p><blockquote><p>JDK8 版本的 <code>HSDB</code> 的 <code>scanoops</code> 会无法扫描到对象，但可以通过 GUI 界面的 <code>Tools -&gt; Object Histogram</code>，输入想要查询的对象，之后双击来获取对象的地址，也可以继续在里面点击 <code>inspect</code> 来查看对象信息</p></blockquote></li><li><p><code>inspect</code>：查看对象（<code>OOP</code>）信息【使用 <code>tools-&gt;inspect</code>，输入对象地址有更详细的信息哦】</p></li><li><p><code>revptrs</code>：反向指针，查找引用该对象的指针</p></li></ul><h2 id="HSDB-GUI界面"><a href="#HSDB-GUI界面" class="headerlink" title="HSDB GUI界面"></a>HSDB GUI界面</h2><h3 id="可视化线程栈"><a href="#可视化线程栈" class="headerlink" title="可视化线程栈"></a>可视化线程栈</h3><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-01.png" style="zoom: 50%;"></p><h3 id="对象直方图"><a href="#对象直方图" class="headerlink" title="对象直方图"></a>对象直方图</h3><p><code>Tools -&gt; Object Histogram</code>，我们可以通过对象直方图快速定位某个类型的对象的地址以供我们进一步分析</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-02.png" style="zoom:50%;"></p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSBD-03.png" style="zoom:50%;"></p><h3 id="OOP信息"><a href="#OOP信息" class="headerlink" title="OOP信息"></a>OOP信息</h3><p>我们可以根据对象地址在 <code>Tools -&gt; Inspector</code> 获取对象的在 JVM 层的实例 <code>instanceOopDesc</code> 对象，它包括对象头 <code>_mark</code> 和 <code>_metadata</code> 以及实例信息</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-04.png" style="zoom:50%;"></p><h3 id="堆信息"><a href="#堆信息" class="headerlink" title="堆信息"></a>堆信息</h3><p>我们可以通过 <code>Tools -&gt; Heap Parameters</code> 获取堆信息，可以结合对象地址判断对象位置</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-05.png" style="zoom:50%;"></p><h3 id="加载类列表"><a href="#加载类列表" class="headerlink" title="加载类列表"></a>加载类列表</h3><p>我们可以通过 <code>Tools -&gt; Class Browser</code> 来获取所有加载类列表</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-06.png" style="zoom:50%;"></p><h4 id="元数据区"><a href="#元数据区" class="headerlink" title="元数据区"></a>元数据区</h4><p>HotSpot VM 里有一套对象专门用来存放元数据，它们包括： </p><ul><li><p><code>Klass</code> 系对象，用于描述类型的总体信息【<strong>通过 <code>OOP</code> 信息（<code>inspect</code>）可以看到 <code>instanceKlass</code> 对象</strong>】</p></li><li><p><code>ConstantPool/ConstantPoolCache</code> 对象：每个 <code>InstanceKlass</code> 关联着一个 <code>ConstantPool</code>，作为该类型的运行时常量池。这个常量池的结构跟 Class 文件里的常量池基本上是对应的</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-07.png" style="zoom:50%;"></p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-08.png" style="zoom:50%;"></p></li><li><p><code>Method</code> 对象，用来描述 Java 方法的总体信息，如方法入口地址、调用/循环计数器等等</p><ul><li><code>ConstMethod</code> 对象，记录着 Java 方法的不变的描述信息，包括方法名、方法的访问修饰符、<strong>字节码</strong>、行号表、局部变量表等等。<strong>注意，字节码指令被分配在 <code>constMethodOop</code> 对象的内存区域的末尾</strong></li><li><code>MethodData</code> 对象，记录着 Java 方法执行时的 profile 信息，例如某方法里的某个字节码之类是否从来没遇到过 null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给 HotSpot Server Compiler 用于做激进优化。</li></ul><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-09.png" style="zoom:50%;"></p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-10.png" style="zoom:50%;"></p></li><li><p><code>Symbol</code> 对象，对应 Class 文件常量池里的 <code>JVM_CONSTANT_Utf8</code> 类型的常量。有一个 VM 全局的 <code>SymbolTable</code> 管理着所有 <code>Symbol</code>。<code>Symbol</code> 由所有 Java 类所共享。</p></li></ul><h4 id="生成class文件"><a href="#生成class文件" class="headerlink" title="生成class文件"></a>生成class文件</h4><p>到对应类下点击 create .class 后就可以在执行 HSDB 的目录下看到生成的 class文件，适合查看动态代理生成的字节码</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="分析对象存储区域"><a href="#分析对象存储区域" class="headerlink" title="分析对象存储区域"></a>分析对象存储区域</h3><p>下面代码中的静态变量，成员变量分别存储在什么地方呢？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> VMShow StaticVmShow = <span class="hljs-keyword">new</span> VMShow();</span><br><span class="line">    <span class="hljs-keyword">private</span> VMShow objVmShow = <span class="hljs-keyword">new</span> VMShow();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> VMShow <span class="hljs-title">fn</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VMShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VMShow</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> basicInt = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer objInt = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer staticInt = <span class="hljs-number">3</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> String basicString = <span class="hljs-string">"basicString"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String staticString = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"staticString"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看对象直方图可以找到三个 VMShow 对象</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-11.png" style="zoom:50%;"></p><p>那么如何确定这三个地址分别属于哪些变量呢？首先找静态变量，它在 JDK8 中是在 Class 对象中的，因此我们可以找它们的反向指针，如果是<code>java.lang.Class</code> 的那么就是静态变量</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-12.png" style="zoom:50%;"></p><p>我们可以从 ObjTest 的 <code>instanceKlass</code> 中的镜像找到 class 对象来验证是否是该对象的 class</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-13.png" style="zoom:50%;"></p><p>那么成员变量和局部变量如何区分呢？成员变量会被类实例引用，而局部变量地址则在会被被放在栈区</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-14.png" style="zoom:50%;"></p><p>那么局部变量的反向指针都是 null，怎么确定它就被栈区所引用呢？我们可以看可视化线程栈</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-15.png" style="zoom:50%;"></p><h3 id="分析字符串字面量存储区域"><a href="#分析字符串字面量存储区域" class="headerlink" title="分析字符串字面量存储区域"></a>分析字符串字面量存储区域</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="hljs-string">"a"</span>;</span><br><span class="line">        String s2 = <span class="hljs-string">"b"</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ab"</span>);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一共涉及的字符串字面量和实例分别存储在什么地方呢？</p><ol><li><p>首先在 s2 处打上断点，启动 <code>HSDB</code> 监控该进程</p></li><li><p>打开对象直方图发现只有 1 个 <code>a</code> 的字符串对象</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-16.png" style="zoom:50%;"></p></li><li><p>查找 StringTable 中 <code>a</code> 的对象地址</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jseval &quot;st = sa.vm.stringTable;st.stringsDo(function (s) &#123; if (sapkg.oops.OopUtilities.stringOopToString(s).matches(&apos;^(a)&apos;)) &#123;print(s + &apos;: &apos;);s.printValueOn(java.lang.System.out); println(&apos;&apos;)&#125;&#125;)&quot;</span><br></pre></td></tr></table></figure><p>可以根据需要改变 <code>matches</code> 中的值来匹配</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-17.png" style="zoom:50%;"></p><p>可以看到这个对象地址就是 StringTable 中引用的地址</p></li><li><p>然后打断点在 sout 上，重新开始监控进程</p></li><li><p>重新使用对象直方图查看 String 值</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-18.png" style="zoom:50%;"></p><p>这里有5个值，<code>ab</code> 有3个：</p><ul><li><code>ab</code> 字面量</li><li>其中 s3 相当于 <code>new StringBuild().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，会创建一个 <code>ab</code> 的实例</li><li>s4会创建一个 <code>ab</code> 的实例</li></ul></li><li><p>我们重新打印 StringTable 相应的值来验证</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jseval &quot;st = sa.vm.stringTable;st.stringsDo(function (s) &#123; if (sapkg.oops.OopUtilities.stringOopToString(s).matches(&apos;^(a|b).?&apos;)) &#123;print(s + &apos;: &apos;);s.printValueOn(java.lang.System.out); println(&apos;&apos;)&#125;&#125;)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-19.png" style="zoom:50%;"></p></li></ol><p>那么运行时常量池中存放的是哪些呢？实际上它和 StringTable 一样是这些对象的引用，只不过 StringTable 是全局共享的，而运行时常量池只有该类的一些字面量。我们通过加载类列表可以查看</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-20.png" alt="image-20190806204906357" style="zoom:50%;"></p><h3 id="分析String-intern"><a href="#分析String-intern" class="headerlink" title="分析String.intern"></a>分析String.intern</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringInternTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"he"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"llo"</span>); <span class="hljs-comment">//  1</span></span><br><span class="line">        s1.intern(); <span class="hljs-comment">// 2</span></span><br><span class="line">        String s2=<span class="hljs-string">"hello"</span>; <span class="hljs-comment">// 3</span></span><br><span class="line">        System.out.println(s1==s2); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"2"</span>); <span class="hljs-comment">// 4</span></span><br><span class="line">        String s4 = <span class="hljs-string">"12"</span>; <span class="hljs-comment">// 5</span></span><br><span class="line">        s3.intern(); <span class="hljs-comment">// 6</span></span><br><span class="line">        System.out.println(s3 == s4);  <span class="hljs-comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述在编译器确定的字面量有 <code>he</code>, <code>llo</code>, <code>hello</code>, <code>1</code>,  <code>2</code>, <code>12</code>，但在真正执行到语句前，符号引用不一定解析成直接引用，即字面量对应的对象会在执行到语句时（<code>idc</code> 指令）才会创建</p><p>首先看通过加载类列表查看字节码指令： </p><table><thead><tr><th>line</th><th>bci</th><th>bytecode</th></tr></thead><tbody><tr><td>7</td><td>0</td><td>new #2 [Class java.lang.StringBuilder]</td></tr><tr><td>7</td><td>3</td><td>dup</td></tr><tr><td>7</td><td>4</td><td>invokespecial #3 [Method void <init>()]</init></td></tr><tr><td>7</td><td>7</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>7</td><td>10</td><td>dup</td></tr><tr><td>7</td><td>11</td><td>ldc #5(0) <string "he"=""> [fast_aldc]</string></td></tr><tr><td>7</td><td>13</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>7</td><td>16</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>7</td><td>19</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>7</td><td>22</td><td>dup</td></tr><tr><td>7</td><td>23</td><td>ldc #8(1) <string "llo"=""> [fast_aldc]</string></td></tr><tr><td>7</td><td>25</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>7</td><td>28</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>7</td><td>31</td><td>invokevirtual #9 [Method java.lang.String toString()]</td></tr><tr><td>7</td><td>34</td><td>astore_1</td></tr><tr><td>8</td><td>35</td><td>aload_1</td></tr><tr><td>8</td><td>36</td><td>invokevirtual #10 [Method java.lang.String intern()]</td></tr><tr><td>8</td><td>39</td><td>pop</td></tr><tr><td>9</td><td>40</td><td>ldc #11(2) <string "hello"=""> [fast_aldc]</string></td></tr><tr><td>9</td><td>42</td><td>astore_2</td></tr><tr><td>10</td><td>43</td><td>getstatic #12 [Field java.io.PrintStream out]</td></tr><tr><td>10</td><td>46</td><td>aload_1</td></tr><tr><td>10</td><td>47</td><td>aload_2</td></tr><tr><td>10</td><td>48</td><td>if_acmpne 55</td></tr><tr><td>10</td><td>51</td><td>iconst_1</td></tr><tr><td>10</td><td>52</td><td>goto 56</td></tr><tr><td>10</td><td>55</td><td>iconst_0</td></tr><tr><td>10</td><td>56</td><td>invokevirtual #13 [Method void println(boolean)]</td></tr><tr><td>12</td><td>59</td><td>new #2 [Class java.lang.StringBuilder]</td></tr><tr><td>12</td><td>62</td><td>dup</td></tr><tr><td>12</td><td>63</td><td>invokespecial #3 [Method void <init>()]</init></td></tr><tr><td>12</td><td>66</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>12</td><td>69</td><td>dup</td></tr><tr><td>12</td><td>70</td><td>ldc #14(3) <string "1"=""> [fast_aldc]</string></td></tr><tr><td>12</td><td>72</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>12</td><td>75</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>12</td><td>78</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>12</td><td>81</td><td>dup</td></tr><tr><td>12</td><td>82</td><td>ldc #15(4) <string "2"=""> [fast_aldc]</string></td></tr><tr><td>12</td><td>84</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>12</td><td>87</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>12</td><td>90</td><td>invokevirtual #9 [Method java.lang.String toString()]</td></tr><tr><td>12</td><td>93</td><td>astore_3</td></tr><tr><td>13</td><td>94</td><td>ldc #16(5) <string "12"=""> [fast_aldc]</string></td></tr><tr><td>13</td><td>96</td><td>astore #4</td></tr><tr><td>14</td><td>98</td><td>aload_3</td></tr><tr><td>14</td><td>99</td><td>invokevirtual #10 [Method java.lang.String intern()]</td></tr><tr><td>14</td><td>102</td><td>pop</td></tr><tr><td>15</td><td>103</td><td>getstatic #12 [Field java.io.PrintStream out]</td></tr><tr><td>15</td><td>106</td><td>aload_3</td></tr><tr><td>15</td><td>107</td><td>aload #4</td></tr><tr><td>15</td><td>109</td><td>if_acmpne 116</td></tr><tr><td>15</td><td>112</td><td>iconst_1</td></tr><tr><td>15</td><td>113</td><td>goto 117</td></tr><tr><td>15</td><td>116</td><td>iconst_0</td></tr><tr><td>15</td><td>117</td><td>invokevirtual #13 [Method void println(boolean)]</td></tr><tr><td>16</td><td>120</td><td>return</td></tr></tbody></table><p>可以看到确实有 6 个<code>idc</code>，但如果我们在第一行语句打上断点，会发现它们都不在 StringTable（但这里的 <code>he</code> 在，它可能被其他类用到了），然后执行第一行，会发现 <code>he</code> 和 <code>llo</code> 在了，但 <code>hello</code> 不在</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jseval &quot;st = sa.vm.stringTable;st.stringsDo(function (s) &#123; if (sapkg.oops.OopUtilities.stringOopToString(s).matches(&apos;^(he|llo|hello|1|2|12)&apos;)) &#123;print(s + &apos;: &apos;);s.printValueOn(java.lang.System.out); println(&apos;&apos;)&#125;&#125;)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-21.png" style="zoom:50%;"></p><p>但是 <code>hello</code> 对象还是存在的（new）</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-22.png" style="zoom:50%;"></p><p>接着执行 s1.intern 会将 <code>hello</code> 对象的地址放入 StringTable</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-23.png" style="zoom:50%;"></p><p>再执行 <code>String s2=&quot;hello&quot;;</code> 会发现 <code>hello</code> 对象仍然只有一个，都指向同一个。</p><p>而继续在 6 打断点，即执行完 <code>String s4 = &quot;12&quot;;</code>，因为 <code>12</code> 不在字符串常量池，那么会新建一个 <code>12</code> 的实例，并让字符串常量池引用它，这样会发现就有两个 <code>12</code> 了</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-24.png" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HSDB（Hotspot Debugger)&lt;/code&gt;，是一款内置于 SA 中的 GUI 调试工具，可用于调试 JVM 运行时数据，从而进行故障排除&lt;/p&gt;
&lt;h2 id=&quot;启动HSDB&quot;&gt;&lt;a href=&quot;#启动HSDB&quot; class=&quot;headerlink&quot; title=&quot;启动HSDB&quot;&gt;&lt;/a&gt;启动HSDB&lt;/h2&gt;&lt;p&gt;检测不同 JDK 版本需要使用不同的 &lt;code&gt;HSDB&lt;/code&gt; 版本，否则容易出现无法扫描到对象等莫名其妙的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mac&lt;/strong&gt;：JDK7 和 JDK8 均可以采用以下的方式&lt;/p&gt;
&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo java -cp ,:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上经过测试，即使通过 JDK8 自带的 &lt;code&gt;sa-jdi.jar&lt;/code&gt; 去扫描对象（&lt;code&gt;scanoops&lt;/code&gt;）的时候也会发生扫不到的情况，但可以通过其他手段代替&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 JDK11 的启动方式有些区别&lt;/p&gt;
&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ /Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/bin/jhsdb hsdb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上经过测试，该版本启动的 &lt;code&gt;HSDB&lt;/code&gt; 会少支持一些指令（比如 &lt;code&gt;mem, whatis&lt;/code&gt;），&lt;strong&gt;因此目前不推荐使用该版本&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;: &lt;/p&gt;
&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ java -classpath &lt;span class=&quot;hljs-string&quot;&gt;&quot;%JAVA_HOME%/lib/sa-jdi.jar&quot;&lt;/span&gt; sun.jvm.hotspot.HSDB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中启动版本可以使用 &lt;code&gt;/usr/libexec/java_home -V&lt;/code&gt; 获取&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若遇到 Unable to locate an executable at “/Users/xx/.jenv/versions/1.7/bin/jhsdb” (-1) 可通过 &lt;code&gt;Jenv&lt;/code&gt; 切换到当前 Jdk 版本即可解决&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="故障排查" scheme="http://yoursite.com/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Static Nested Or Inner Classes</title>
    <link href="http://yoursite.com/2019/12/06/Static-Nested-Or-Inner-Classes/"/>
    <id>http://yoursite.com/2019/12/06/Static-Nested-Or-Inner-Classes/</id>
    <published>2019-12-06T07:35:59.000Z</published>
    <updated>2020-02-06T06:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，在一个类中声明另一个类则称为嵌套类，被声明为 <code>static</code> 的嵌套类称为静态嵌套类（<code>static nested classes</code> ），与之相对的非静态嵌套类被称为内部类(（<code>inner classes</code> ）</p><ul><li><p>非静态嵌套类每个实例都包含一个额外指向外围对象的引用，换句话说，要实例化一个非静态嵌套类必须首先实例化外部类</p></li><li><p>静态嵌套类独立于外部类实例，可以看作嵌套在一个顶级类中的顶级类。因此，如果嵌套类不要求访问外部类的实例变量或方法，就要始终把 <code>static</code> 修饰符放在它的声明中，使它成为静态嵌套类。（如果该嵌套类不作为基类，那么更适合同时加上 <code>final</code> 修饰符）。JDK1.8 源码可见各种这样的设计，如 ReentrantLock 中</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们从四个方面来更详细的讨论它们的区别：</p><ul><li><p>嵌套类访问外部类的范围</p></li><li><p>嵌套类本身定义变量的范围</p></li><li><p>实例化</p></li><li><p>同名覆盖</p></li></ul><a id="more"></a><h1 id="非静态嵌套类"><a href="#非静态嵌套类" class="headerlink" title="非静态嵌套类"></a>非静态嵌套类</h1><ul><li><p>非静态嵌套类和外部类的实例关联，可以直接访问外部类的所有方法和字段</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"OuterClass..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样由于非静态嵌套类和外部类的实例相关联，所以它不能自己定义任何静态成员</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> failedField = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">      </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failedMethod</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要先实例化外部类，再实例化非静态嵌套类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass outerClass = <span class="hljs-keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.InnerClass innerClass = outerClass.new InnerClass();</span><br></pre></td></tr></table></figure></li><li><p>同名覆盖问题，非静态嵌套类仅会出现在实例变量或方法中，非静态嵌套类中声明的实例同名变量或方法会覆盖外部类的声明，访问外部类的实例变量或方法需要加上 <code>外部类名.this</code>，如 <code>OuterClass.this.x</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"OuterClass..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-keyword">this</span>.j);  <span class="hljs-comment">// 3</span></span><br><span class="line">            System.out.println(OuterClass.<span class="hljs-keyword">this</span>.j); <span class="hljs-comment">// 2</span></span><br><span class="line">            <span class="hljs-keyword">this</span>.display();  <span class="hljs-comment">// InnerClass..</span></span><br><span class="line">            OuterClass.<span class="hljs-keyword">this</span>.display();  <span class="hljs-comment">// OuterClass...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"InnerClass..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="静态嵌套类"><a href="#静态嵌套类" class="headerlink" title="静态嵌套类"></a>静态嵌套类</h1><ul><li><p>静态嵌套类和外部类（非实例）相关联，因此仅能访问外部类的静态变量和方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticField = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> normalField = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">normalMethod</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(staticField);  <span class="hljs-comment">// 编译通过</span></span><br><span class="line">          System.out.println(normalField);  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">          staticMethod();  <span class="hljs-comment">// 编译通过</span></span><br><span class="line">          normalMethod();  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于静态嵌套类不依赖于外部类实例，所以它可以定义任意变量和方法（和普通类相同）</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</span><br><span class="line">          <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">normalDisplay</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">              System.out.println(i);</span><br><span class="line">              System.out.println(j);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticDisplay</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">              System.out.println(j);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以直接实例化静态嵌套类，且不会实例化外部类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass staticNestedClass = <span class="hljs-keyword">new</span> OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure></li><li><p>同名覆盖问题，静态嵌套类仅会出现静态变量或方法重名，静态嵌套类中声明的静态同名变量或方法会覆盖外部类的声明，访问外部类的静态变量或方法需要加上外部类名，如 <code>OuterClass.x</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNestedClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(i);  <span class="hljs-comment">// 1</span></span><br><span class="line">            System.out.println(j);  <span class="hljs-comment">// 2</span></span><br><span class="line">          System.out.println(OuterClass.j);  <span class="hljs-comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后关于序列化，根据 Oracle 官方建议，强烈不推荐序列化非静态嵌套类，原因参考 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">Nested Classes</a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>当一个类的构造函数需要传入多个参数，且很多参数是可选的，传统做法是重载构造函数。这将导致几个问题</p><ul><li>由于可选参数多，因此会有大量重载构造函数，也就是说会存在大量重复代码</li><li>客户端调用比较困难，使用者需要选择合适的构造函数，以及了解每个参数的含义和顺序</li></ul><p>因此比较合适的方式是使用 <code>Builder</code> 模式代替重载构造函数，它隐藏了内部的具体构建细节，允许多个可选参数，具有很强的可读性。而 <code>Builder</code> 模式就是使用静态嵌套类实现的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseVideoParseBo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 电影</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String movie;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 搜索链接</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String searchUrl;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 电影标题</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 时长</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String time;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 清晰度</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String bagde;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 封面</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String imgUrl;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 视频链接</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; videoUrls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 渠道</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BaseVideoParseBo</span><span class="hljs-params">(Builder&lt;?&gt; builder)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.movie = builder.movie;</span><br><span class="line">        <span class="hljs-keyword">this</span>.bagde = builder.bagde;</span><br><span class="line">        <span class="hljs-keyword">this</span>.searchUrl = builder.searchUrl;</span><br><span class="line">        <span class="hljs-keyword">this</span>.time = builder.time;</span><br><span class="line">        <span class="hljs-keyword">this</span>.title = builder.title;</span><br><span class="line">        <span class="hljs-keyword">this</span>.imgUrl = builder.imgUrl;</span><br><span class="line">        <span class="hljs-keyword">this</span>.channel = builder.channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> Class&lt;T&gt; subBuilder;</span><br><span class="line">        <span class="hljs-keyword">private</span> String movie;</span><br><span class="line">        <span class="hljs-keyword">private</span> String searchUrl;</span><br><span class="line">        <span class="hljs-keyword">private</span> String title;</span><br><span class="line">        <span class="hljs-keyword">private</span> String time;</span><br><span class="line">        <span class="hljs-keyword">private</span> String bagde;</span><br><span class="line">        <span class="hljs-keyword">private</span> String imgUrl;</span><br><span class="line">        <span class="hljs-keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(Class&lt;T&gt; subBuilder)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.subBuilder = subBuilder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">movie</span><span class="hljs-params">(String movie)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.movie = movie;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">searchUrl</span><span class="hljs-params">(String searchUrl)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.searchUrl = searchUrl;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">title</span><span class="hljs-params">(String title)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.title = title;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">time</span><span class="hljs-params">(String time)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.time = time;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">bagde</span><span class="hljs-params">(String bagde)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.bagde = bagde;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">imgUrl</span><span class="hljs-params">(String imgUrl)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.imgUrl = imgUrl;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">channel</span><span class="hljs-params">(String channel)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.channel = channel;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">self</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> subBuilder.cast(<span class="hljs-keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> BaseVideoParseBo <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BaseVideoParseBo(<span class="hljs-keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVideoUrls</span><span class="hljs-params">(List&lt;String&gt; videoUrls)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.videoUrls.addAll(videoUrls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVideoUrl</span><span class="hljs-params">(String videoUrl)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.videoUrls.add(videoUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建该类对象代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 仅使用基类时</span></span><br><span class="line">BaseVideoParseBo baseVideoParseBo = <span class="hljs-keyword">new</span> BaseVideoParseBo.Builder&lt;&gt;(BaseVideoParseBo.Builder.class)</span><br><span class="line">.xxx()</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>这里再做一些拓展，可以看到上述类大量使用了泛型，其主要用于解决 <code>Builder</code> 继承时的返回类型问题，因此结合了 <code>Builder</code> 模式和协变返回类型，其子类可以如下实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubParseBo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseVideoParseBo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 是否获取所有清晰度的视频</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allVideos;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String dataId;</span><br><span class="line">    <span class="hljs-keyword">private</span> String dataInfo;</span><br><span class="line">    <span class="hljs-keyword">private</span> String videoId;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">SubParseBo</span><span class="hljs-params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(builder);</span><br><span class="line">        <span class="hljs-keyword">this</span>.dataId = builder.dataId;</span><br><span class="line">        <span class="hljs-keyword">this</span>.allVideos = builder.allVideos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseVideoParseBo</span>.<span class="hljs-title">Builder</span>&lt;<span class="hljs-title">Builder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allVideos;</span><br><span class="line">        <span class="hljs-keyword">private</span> String dataId;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">super</span>(Builder.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">dataId</span><span class="hljs-params">(String dataId)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.dataId = dataId;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">allVideos</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> allVideos)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.allVideos = allVideos;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> SubParseBo <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SubParseBo(<span class="hljs-keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataInfo</span><span class="hljs-params">(String dataInfo)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.dataInfo = dataInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVideoId</span><span class="hljs-params">(String videoId)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.videoId = videoId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么构建子类对象如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubParseBo parseBo = <span class="hljs-keyword">new</span> SubParseBo.Builder()</span><br><span class="line">                .xxx</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中，在一个类中声明另一个类则称为嵌套类，被声明为 &lt;code&gt;static&lt;/code&gt; 的嵌套类称为静态嵌套类（&lt;code&gt;static nested classes&lt;/code&gt; ），与之相对的非静态嵌套类被称为内部类(（&lt;code&gt;inner classes&lt;/code&gt; ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;非静态嵌套类每个实例都包含一个额外指向外围对象的引用，换句话说，要实例化一个非静态嵌套类必须首先实例化外部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态嵌套类独立于外部类实例，可以看作嵌套在一个顶级类中的顶级类。因此，如果嵌套类不要求访问外部类的实例变量或方法，就要始终把 &lt;code&gt;static&lt;/code&gt; 修饰符放在它的声明中，使它成为静态嵌套类。（如果该嵌套类不作为基类，那么更适合同时加上 &lt;code&gt;final&lt;/code&gt; 修饰符）。JDK1.8 源码可见各种这样的设计，如 ReentrantLock 中&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NonfairSync&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Sync&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从四个方面来更详细的讨论它们的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;嵌套类访问外部类的范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;嵌套类本身定义变量的范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同名覆盖&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>泛型进阶</title>
    <link href="http://yoursite.com/2019/12/06/%E6%B3%9B%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2019/12/06/泛型进阶/</id>
    <published>2019-12-06T07:19:10.000Z</published>
    <updated>2020-02-06T05:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无限制通配符"><a href="#无限制通配符" class="headerlink" title="无限制通配符"></a>无限制通配符</h2><p>无限通配符即： <code>&lt;?&gt;</code>，主要在不确定或不关心实际参数类型时使用，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于它不确定具体类型，所以不能将任何元素（<code>Null</code> 除外）放入，即它是只读的，但在很多情况下需要放入对象，因此一种比较常见的方法是使用 <strong>类型参数</strong> 作为辅助函数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;?&gt; list, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">swapHelper(list, i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapHelper</span><span class="hljs-params">(List&lt;E&gt; list, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">list.set(i, list.get(j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>List&lt;?&gt;</code> 和 <code>List&lt;Object&gt;</code> 有什么区别呢？</p><a id="more"></a><ol><li><p><code>List&lt;Object&gt;</code> 已经指定了类型的参数，而泛型具有不变性，所以它只能传入参数类型为 <code>Object</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;());  <span class="hljs-comment">// 正确</span></span><br><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());  <span class="hljs-comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;Object&gt; list)</span></span>&#123;</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>List&lt;?&gt;</code> 是无限制通配符类型，它可以表示为任意的实际的类型参数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;()); <span class="hljs-comment">// 正确</span></span><br><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());  <span class="hljs-comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>List&lt;Object&gt;</code> 的类型参数已经确定，所以可以对其中的元素进行诸如 <code>get</code> , <code>add</code> 、<code>remove</code> 等操作</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;Object&gt; list)</span></span>&#123;</span><br><span class="line">list.add(<span class="hljs-string">"str"</span>);</span><br><span class="line">list.add(<span class="hljs-number">1</span>);</span><br><span class="line">list.remove(<span class="hljs-string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>List&lt;?&gt;</code> 是只读的，不能 <code>add</code> ，只能 <code>get</code> <code>,</code> <code>remove</code> 操作（当然可以使用上述的辅助函数实现 <code>add</code>），且返回元素都是 <code>Object</code> 类型的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">list.get(<span class="hljs-number">0</span>);</span><br><span class="line">list.remove(<span class="hljs-string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以一般情况下，使用无限制通配符的优先级大于 <code>Object</code> 作为类型参数</p><h2 id="有限制通配符"><a href="#有限制通配符" class="headerlink" title="有限制通配符"></a>有限制通配符</h2><p><code>java</code> 泛型有两种有限制通配符，<code>&lt;? extends E&gt;</code> 和 <code>&lt;? super E&gt;</code>，那么它们的作用是什么呢？这要从协变和逆变说起。</p><h3 id="协变（Covariance）和逆变（Contravariance）"><a href="#协变（Covariance）和逆变（Contravariance）" class="headerlink" title="协变（Covariance）和逆变（Contravariance）"></a>协变（Covariance）和逆变（Contravariance）</h3><p>逆变与协变用来描述类型转换（<em>type transformation</em>）后的继承关系</p><ul><li><strong>协变：具有子类型关系之间的类型经过“类型转换”后，所构造出更复杂的类型之间仍保持着子类型关系。</strong></li><li><strong>逆变：具有子类型关系之间的类型经过“类型转换”后，所构造的更复杂的类型之间建立了逆向子类型关系。</strong></li><li><strong>不变：具有子类型关系之间的类型经过“类型转换”后，所构造的更复杂的类型之间没有任何关系</strong></li></ul><p>这里指的类型转换代表指的是从一种类型构造为另一种新的类型，如 <code>String</code> 到 <code>String[]</code>，<code>String</code> 到 <code>List&lt;String&gt;</code>。在 <code>java</code> 中，泛型具有不变性，如</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number number = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>);  <span class="hljs-comment">// True</span></span><br><span class="line">ArrayList&lt;Number&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();  <span class="hljs-comment">// True</span></span><br><span class="line">ArrayList&lt;Number&gt; arrayList1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">ArrayList&lt;Number&gt; arrayList1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();  <span class="hljs-comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>那么问题的答案就出现了：有限制通配符是为了实现泛型的协变与逆变</p><ul><li><p><code>&lt;? extends E&gt;</code> 实现了泛型的协变：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Number&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;? super E&gt;</code> 实现了泛型的逆变：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="hljs-keyword">super</span> Number&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li></ul><h3 id="extends-与-super"><a href="#extends-与-super" class="headerlink" title="extends 与 super"></a>extends 与 super</h3><p>有限制通配符有它的局限性，看一个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p>我们通过 <code>extends</code> 通配符构建了对象，但是却不能插入 <code>Integer</code> 类型的元素，这看起来很不合理。其实这是可以理解的，首先看一些 <code>List</code> 类的 <code>add</code> 方法接口</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>add</code> 方法时，泛型 <code>E</code> 自动变成了 <code>&lt;? extends Number&gt;</code>，也就是说其类型是 <code>Number</code> 的子类中的一个（不含 <code>Number</code>），因此 <code>add</code> 一个  <code>Integer</code> 类型对象是错误的。如果要实现 <code>add</code> 一个 <code>Interger</code> 对象，可以使用 <code>super</code> 关键字</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="hljs-keyword">super</span> Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p><code>&lt;? super Number&gt;</code> 代表其持有的类型是 <code>Number</code> 的父类，那么 <code>add</code> 一个  <code>Integer</code> 类型对象是正确的。所以我们又可以总结出：</p><ul><li><code>&lt;? extends Number&gt;</code>  是只读的</li></ul><ul><li><code>&lt;? super Number&gt;</code>  是只写的</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>那么究竟什么时候用 <code>extends</code>，什么时候用 <code>super</code> 呢？其实很简单，遵循 <code>PECS</code> 原则</p><blockquote><p><em>PECS: producer-extends, consumer-super</em>. 换句话说：</p><ul><li>如果要从泛型类取数据时，用 <code>extends</code></li><li>如果要往泛型类写数据时，用 <code>super</code></li></ul></blockquote><p>举几个例子，首先看 <code>java.util.AbstractList</code> 的 <code>addAll</code> 方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">rangeCheckForAdd(index);</span><br><span class="line"><span class="hljs-keyword">boolean</span> modified = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (E e : c) &#123;  <span class="hljs-comment">// 注意这里，从泛型类中获取对象!!</span></span><br><span class="line">add(index++, e);</span><br><span class="line">modified = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addAll</code> 方法需要将传入的泛型类中的所有元素保存到当前集合中，因此将从泛型类读取所有元素，所以使用 <code>extends</code>。又如 <code>java.util.Collections</code> 的 <code>copy</code> 方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> srcSize = src.size();</span><br><span class="line"><span class="hljs-keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Source does not fit in dest"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">(src <span class="hljs-keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="hljs-keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">dest.set(i, src.get(i));  <span class="hljs-comment">// 从src泛型类读取数据，写入dest泛型类！！！</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">ListIterator&lt;? <span class="hljs-keyword">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">di.next();</span><br><span class="line">di.set(si.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>copy</code> 方法将一个集合中的元素拷贝到另一个集合，完美的诠释了有限制通配符的使用。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>考虑以下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span>&#123;</span><br><span class="line">T max = coll.iterator().next();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (T elm : coll) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (max.compareTo(elm) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">max = elm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是对集合中的元素进行排序，那么我们需要对传入的集合中的元素进行限定，它需要能够进行比较，即实现 <code>Comparable</code> 接口，<code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 的作用就是如此。但在继承关系中，上述声明会出现错误，考虑以下情况：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Fruit that)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (size &lt; that.size)</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size == that.size)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Apple</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"Apple"</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Apple</code> 类继承了 <code>Fruit</code> 类，但是它没有实现 <code>Comparable&lt;Apple&gt;</code>，而是实现了 <code>Comparable&lt;Fruit&gt;</code>，因此它不符合 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 要求，因此不能对 <code>Apple</code> 集合使用</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">10</span>));</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">20</span>));</span><br><span class="line"></span><br><span class="line">Algorithm.&lt;Apple&gt;max(list);  <span class="hljs-comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p> 因此，为了能够对这种情况予以支持，需要使用如下声明：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>的限定含义是：</p><ul><li><code>T implements Comparable&lt;T&gt;</code></li><li><code>T implements Comparable&lt;X&gt;</code>，其中 <code>X</code> 是 <code>T</code> 的父类</li></ul><blockquote><p>其实以之前的 <code>PECS</code> 原则也能很好的解释，无论是 <code>Comparable</code> 还是 <code>Comparator</code>，它们的方法都需要写数据，即向泛型类写数据，所以需要使用  <code>&lt;? super T&gt;</code> ，所以使用  <code>Comparator</code> 的声明为：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;T&gt; coll, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure></blockquote><p>其实到这里为止，这个 <code>API</code> 已经能够支持大部分情况了。但是假设我们需要传入的泛型集合是 <code>T</code> 的子类，将会仍然编译错误</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Algorithm.&lt;Fruit&gt;max(list);  <span class="hljs-comment">// T为Fruit，传入的是List&lt;Apple&gt;，编译错误</span></span><br></pre></td></tr></table></figure><p>这就是之前说的泛型的不变性问题，因此，最灵活的声明是：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span><br></pre></td></tr></table></figure><p>也许你不太明白我们这样使用它的意义，为什么一定要强制加一个 <code>&lt;Fruit&gt;</code> 呢？看起来没什么必要，其实这是在模拟一种情况，上述的声明等同于如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Algorithm</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;? <span class="hljs-title">super</span> <span class="hljs-title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span> </span>&#123;</span><br><span class="line">        T max = coll.iterator().next();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (T elm : coll) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (max.compareTo(elm) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">                max = elm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的调用是不是就比较常见了</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">10</span>));</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">20</span>));</span><br><span class="line"></span><br><span class="line">Algorithm&lt;Fruit&gt; fruitAlgorithm = <span class="hljs-keyword">new</span> Algorithm&lt;&gt;();</span><br><span class="line">fruitAlgorithm.max(list);</span><br></pre></td></tr></table></figure><p>其实 <code>java.util.Collections</code> 的 <code>max</code> 方法可以看到类似的声明：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span> </span>&#123;</span><br><span class="line">Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class="line">T candidate = i.next();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">T next = i.next();</span><br><span class="line"><span class="hljs-keyword">if</span> (next.compareTo(candidate) &gt; <span class="hljs-number">0</span>)</span><br><span class="line">candidate = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用 <code>Object &amp;</code> 主要是因为泛型擦除，编译生成的 <code>Java</code> 字节码中是不包含泛型中的类型信息，泛型类型会被 <code>Object</code> 所代替（无限制通配符也用 <code>Object</code>），而有限制通配符则会被第一个边界的类型变量来替换，如上面的声明会被 <code>Comparable</code> 所代替，使用了 <code>Object &amp;</code> 后将被 <code>Object</code> 所代替，参看 <a href="https://stackoverflow.com/questions/19488357/why-is-t-bounded-by-object-in-the-collections-max-signature" target="_blank" rel="noopener"><em>Why is T bounded by Object in the Collections.max() signature?</em></a></p><h2 id="泛型单例类"><a href="#泛型单例类" class="headerlink" title="泛型单例类"></a>泛型单例类</h2><p>实现一个泛型单例类，使得它能够对于传入任意类型的 <code>Class</code> 对象都创建一个单例对象</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; INSTANCE_MAP = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getInstance</span><span class="hljs-params">(Class&lt;T&gt; tClass)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Object instance = INSTANCE_MAP.get(tClass);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (INSTANCE_MAP)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                        instance = tClass.newInstance();</span><br><span class="line">                        INSTANCE_MAP.put(tClass, instance);</span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Class的cast方法能够动态的将Object类型转换为Class对象所表示的类型，如果能转就返回，不能转就抛出类型转换失败异常</span></span><br><span class="line">        <span class="hljs-comment">// 这样就不需要借助于未受检警告（(T)instance）</span></span><br><span class="line">        <span class="hljs-keyword">return</span> tClass.cast(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>Persion</code> 类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 姓名</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 身份证</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    String idcard;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 年龄</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 电子邮件</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将它传入泛型单例类，每次 <code>getInstance</code> 可以得到相同的对象</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Singleton.getInstance(Person.class) == Singleton.getInstance(Person.class));  <span class="hljs-comment">// True</span></span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-不应使用原生态类型"><a href="#1-不应使用原生态类型" class="headerlink" title="1. 不应使用原生态类型"></a>1. 不应使用原生态类型</h3><p>原生态类型即不带实际类型参数的泛型名称，如 <code>List&lt;E&gt;</code> 的原生态类型为 <code>List</code>。它<strong>逃避了泛型检查</strong>，当你不小心插入了类型错误的对象，在运行时转换对象会出现 <code>ClassCastException</code> 。因此应该摈弃这样的做法，取而代之使用泛型，优点有以下两点：</p><ol><li>在编译期间进行类型检查</li><li>获取对象不需要手动转换类型</li></ol><p>例子如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 原生态类型，不推荐</span></span><br><span class="line">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="hljs-string">"str"</span>);</span><br><span class="line">list.add(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (Object o : list) &#123;</span><br><span class="line">String s = (String)o;  <span class="hljs-comment">// 抛出ClassCastException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 泛型，推荐</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="hljs-string">"str"</span>);</span><br><span class="line">list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1. 编译期检查错误，不允许添加整形</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (String o : list) &#123;</span><br><span class="line">String s = o;  <span class="hljs-comment">// 2. 不需手动转换类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不要使用通配符类型作为返回类型"><a href="#2-不要使用通配符类型作为返回类型" class="headerlink" title="2. 不要使用通配符类型作为返回类型"></a>2. 不要使用通配符类型作为返回类型</h3><p>使用通配符类型作为返回类型将会强制在客户端代码中使用通配符类型，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 使用通配符类型作为返回类型，不推荐</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">List&lt;?&gt; list = returnGenericsType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> List&lt;?&gt; returnGenericsType()&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-泛型无法使用instanceof"><a href="#3-泛型无法使用instanceof" class="headerlink" title="3. 泛型无法使用instanceof"></a>3. 泛型无法使用instanceof</h3><p>由于泛型擦除，编译期间会擦除类型参数，所以不能使用 <code>instanceof</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span>(list <span class="hljs-keyword">instanceof</span> List&lt;Apple&gt;)&#123;  <span class="hljs-comment">// 错误</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于无限制通配符是可以使用 <code>instanceof</code> 的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span>(list <span class="hljs-keyword">instanceof</span> List&lt;?&gt;)&#123;  <span class="hljs-comment">// 错误</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然尖括号和 <code>?</code> 有些多余，可以直接判断</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list <span class="hljs-keyword">instanceof</span> List</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;无限制通配符&quot;&gt;&lt;a href=&quot;#无限制通配符&quot; class=&quot;headerlink&quot; title=&quot;无限制通配符&quot;&gt;&lt;/a&gt;无限制通配符&lt;/h2&gt;&lt;p&gt;无限通配符即： &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;，主要在不确定或不关心实际参数类型时使用，如：&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeAll&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于它不确定具体类型，所以不能将任何元素（&lt;code&gt;Null&lt;/code&gt; 除外）放入，即它是只读的，但在很多情况下需要放入对象，因此一种比较常见的方法是使用 &lt;strong&gt;类型参数&lt;/strong&gt; 作为辅助函数&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;?&amp;gt; list, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	swapHelper(list, i, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swapHelper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;E&amp;gt; list, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	list.set(i, list.get(j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 有什么区别呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>SELECT FOR UPDATE语句深度解析</title>
    <link href="http://yoursite.com/2019/06/18/SELECT-FOR-UPDATE%E8%AF%AD%E5%8F%A5%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/06/18/SELECT-FOR-UPDATE语句深度解析/</id>
    <published>2019-06-18T14:19:04.000Z</published>
    <updated>2020-02-06T05:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>Mysql</code> 的 <code>SELECT ... FOR UPDATE</code> 语句是日常使用较多的用于锁定资源，确保在多个事务读取数据时始终能够读取到最新版本的数据的有效语句。那么它是怎么实现呢？在经过官网文档以及大量实践的验证之后发现网上存在大量不严谨甚至错误的信息，因此通过本文对 <code>SELECT FOR UPDATE</code> 语句作出以下总结。在具体介绍之前，先对目前网上教程或博客中会提到的几个<strong>常见误区</strong>进行纠正：</p><ul><li><p><del><code>SELECT FOR UPDATE</code> 在xx情况下会添加表级锁。</del> </p><p>请注意，<strong>在任何情况下 <code>SELECT FOR UPDATE</code> 都不会添加表级锁。</strong>事实上，在大部分情况下（DQL 语句，DML 语句，DDL 语句）都不会添加表锁，取而代之的是各种类型的行锁。</p><blockquote><p><i class="far fa-bell"></i> </p><p>&emsp;&emsp;那么我们如何获取表锁呢？语句如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLES</span> xx <span class="hljs-keyword">READ</span>; <span class="hljs-comment"># 为 xx 表添加表级 S 锁</span></span><br><span class="line"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLES</span> xx WRITE;  <span class="hljs-comment"># 为 xx 表添加表级 X 锁</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过以下语句来检测当前 Mysql 有哪些表获取了表级锁</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">WHERE</span> In_use &gt; <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><p>更多的表级锁相关知识请参考<a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html#table-lock-release" target="_blank" rel="noopener">官网介绍</a></p></blockquote></li><li><p><del><code>SELECT FOR UPDATE</code> 在未使用索引时会”锁表”。</del></p><p><code>SELECT FOR UPDATE</code> 确实可以通过 <code>Next-key lock</code> 锁住所有记录和间隙来实现和表锁类似的效果。但未使用索引并非充分条件，我们判断 <code>SELECT FOR UPDATE</code> 是否锁住了所有数据和间隙还需要看它的隔离级别。</p></li></ul><a id="more"></a><p>那么影响我们判断 <code>SELECT FOR UPDATE</code> 语句持有什么锁的因素有哪些呢？在这里列出以下几点：</p><ul><li>隔离级别（RC/RR）</li><li>执行计划（聚簇索引/唯一索引/二级索引/无索引）</li><li>过滤条件（等值条件/范围条件）</li></ul><p><strong>以下分析内容均建立在已经了解 Mysql 的行级锁的类型和作用范围的基础上，同时列出几点必要的前提论据：</strong></p><ul><li><p>一般情况下，RC 级别是无法使用 <code>Gap Lock</code> 的，但在检查外键约束或者 duplicate key 检查时还是会用到的</p><blockquote><p>Gap locking can be disabled explicitly. This occurs if you change the transaction isolation level to READ COMMITTED. Under these circumstances, gap locking is disabled for searches and index scans and is used only for foreign-key constraint checking and duplicate-key checking.</p><footer><strong>MySQL 8.0 Reference Manual</strong><cite><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">15.7.1 InnoDB Locking</a></cite></footer></blockquote></li><li><p>一般情况下，执行计划根据某个索引查询后，会将过滤完的记录加锁后返回给 MySQL Server 进行过滤。在 RC 隔离级别下，当记录不满足条件时 MySQL Server 会调用 <code>handler::unlock_row()</code> 告诉存储引擎释放锁（破坏了 2PL 规则），RR 隔离级别下则会保持到事务提交</p><blockquote><p><i class="far fa-bell"></i> </p><ul><li>2PL（<a href="https://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">两阶段加锁协议</a>）是数据库中保证事务并发的控制方法，即保证多个事务在并发的情况下等同于串行的执行。它将加锁和解锁分为两个阶段。而为了在事务中能够明确的判断什么是加锁阶段，什么是解锁阶段，引入了 S2PL（Strict-2PL），即<strong>在事务中只有提交（commit）或者回滚（rollback）时才是解锁阶段，其余时间为加锁阶段。</strong></li><li><p>ICP（索引条件下推）：是一种减少 server 层和 engine 层之间交互的次数的优化方式。上面提到一般情况下对于根据索引查询返回的记录将交由 MySQL Server 进行过滤，而如果过滤条件是联合索引且无法走联合索引时，如：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 联合索引：(index1, index2, index3)</span></span><br><span class="line"><span class="hljs-comment"># 根据最左匹配原则无法走联合索引</span></span><br><span class="line"><span class="hljs-keyword">select</span> x <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> index1 = <span class="hljs-string">‘xx’</span> <span class="hljs-keyword">and</span> index3 <span class="hljs-keyword">like</span> <span class="hljs-string">‘%xxxx%’</span></span><br></pre></td></tr></table></figure><p>正常情况下在对 index1 进行筛选后的记录就要返回。而经过 ICP 优化，由于 where 的查询列属于该联合索引，那么会将对该 where 条件记录过滤后才返回给 server 层</p></li></ul><p>参考：</p><ul><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">MySQL 加锁处理分析</a> </li><li><a href="http://mysql.taobao.org/monthly/2016/01/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 事务锁系统简介</a> </li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual  8.2.1.5 Index Condition Pushdown Optimization</a> </li><li><a href="https://bugs.mysql.com/bug.php?id=20390" target="_blank" rel="noopener">SELECT FOR UPDATE does not release locks of untouched rows in full table scans</a></li></ul></blockquote></li></ul><h2 id="RC级别下的SELECT-FOR-UPDATE"><a href="#RC级别下的SELECT-FOR-UPDATE" class="headerlink" title="RC级别下的SELECT FOR UPDATE"></a>RC级别下的SELECT FOR UPDATE</h2><p>虽然 Mysql 默认的事务隔离级别是 RR，但是在大多数互联网应用中 Mysql 的隔离级别会设置为 RC，因此我们也首先讨论 RC 隔离级别下的 <code>SELECT FOR UPDATE</code>。</p><ul><li><p><strong>在执行计划不走索引时，将只会为满足条件的记录添加 <code>Record Lock</code> </strong></p><blockquote><p>执行计划不走索引代表 sql 会走聚簇索引的全扫描，对所有记录加锁后返回给 MySQL Server 进行过滤。过滤过程中不满足条件的记录的锁会被释放，因此最终只锁住了满足条件的记录</p></blockquote></li><li><p><strong>在执行计划走聚簇索引时，将只为满足条件的记录添加 <code>Record Lock</code> </strong></p></li><li><p><strong>在执行计划走唯一索引或二级索引时，将会为满足条件的记录所在的聚簇索引和二级索引添加 <code>Record Lock</code>  </strong></p><blockquote><p>为什么还需要在聚簇索引加锁呢？因为如果不锁聚簇索引意味着别的事务可以使用 <code>update/delete</code>，那么就失去了锁定资源的作用了</p></blockquote></li></ul><p>从上面的分析可以看出，在 RC 级别下任何情况下都不会出现”锁表”效果。但是<strong>请注意即使 <code>SELECT FOR UPDATE</code> 的目标记录没有被锁住，也是有可能造成阻塞的。</strong>原因在于 <em>Mysql 对非索引过滤（即是由 Mysql Server 过滤）的记录加锁返回的过程是不会省略的</em>，因此如果 <code>SELECT FOR UPDATE</code> 不走索引，那么 Mysql 会为聚簇索引的所有数据行尝试添加  <code>Record Lock</code> ，而一旦有任何一行已经被锁定，那么当前查询就会被阻塞。</p><h2 id="RR级别下的SELECT-FOR-UPDATE"><a href="#RR级别下的SELECT-FOR-UPDATE" class="headerlink" title="RR级别下的SELECT FOR UPDATE"></a>RR级别下的SELECT FOR UPDATE</h2><p>Mysql 的 RR 级别为了解决幻读引入了 <code>Gap Lock</code>，这也为 <code>SELECT FOR UPDATE</code> 的加锁增加了很多可能性</p><ul><li><p><strong>在执行计划不走索引时，将会聚簇索引中的所有记录添加 <code>Next-key Lock</code>，相当于”锁表”</strong></p><blockquote><p>RR 级别下非索引过滤的记录即使不符合过滤条件，锁也不会被释放。同时为了解决幻读，记录添加 <code>Next-key Lock</code> 来锁定间隙</p></blockquote></li><li><p><strong>在执行计划走聚簇索引时，若是能够命中的等值查询，将只为满足条件的记录添加 <code>Record Lock</code>；否则将覆盖范围包含过滤范围的记录添加 <code>Next-key Lock</code></strong>。</p><blockquote><p>为什么只有在等值查询是才有可能添加 <code>Record Lock</code> ？因为范围查询内的数据存在幻读问题</p></blockquote></li><li><p><strong>在执行计划走唯一索引时，锁住唯一索引的方式和聚簇索引相似，同时使用 <code>Record Lock</code> 锁住命中的聚簇索引</strong></p><blockquote><p>为什么只需要使用 <code>Record Lock</code> 锁住聚簇索引？因为通过唯一索引可以保证过滤范围间无法插入数据（与插入意向锁互斥），因此只需要 <code>Record Lock</code> 锁来确定目标记录不被 <code>update/delete</code> 即可</p></blockquote></li><li><p><strong>在执行计划走二级索引时，无论是否为等值查询都会为覆盖范围包含过滤范围的记录添加 <code>Next-key</code>，同时使用 <code>Record Lock</code> 锁住命中的聚簇索引</strong></p><blockquote><p>为什么二级索引不区分等值查询呢？因为即使是等值查询也不能唯一定位二级索引中的数据，在一棵二级索引的 B+ 树中，叶子结点由 二级索引列值 + 主键值 确定的，仅仅依靠二级索引列值还是相当于范围查询</p></blockquote></li></ul><h2 id="Serializable下的SELECT-FOR-UPDATE"><a href="#Serializable下的SELECT-FOR-UPDATE" class="headerlink" title="Serializable下的SELECT FOR UPDATE"></a>Serializable下的SELECT FOR UPDATE</h2><p>Serializable 级别下 <code>SELECT FOR UPDATE</code> 的加锁方式基本和RR级别相同。比较特殊的是，Serializable 下是不存在快照读的，即使查询语句不添加 <code>for update</code> 也会为记录添加共享锁</p><h2 id="锁分析工具"><a href="#锁分析工具" class="headerlink" title="锁分析工具"></a>锁分析工具</h2><p>Mysql 提供了语句来查询当前持有锁的状态和类型等等，是验证我们的判断的利器。语句如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> performance_schema.data_locks</span><br></pre></td></tr></table></figure><p>它提供几个关键信息：</p><ul><li>LOCK_TYPE：锁类型，<code>RECORD</code> 代表行锁，<code>TABLE</code> 代表表锁</li><li>LOCK_MODE：锁模式，<code>X,REC_NOT_GAP</code> 代表 <code>Record Lock</code> , <code>X, GAP</code> 代表 <code>Gap Lock</code> , <code>X</code> 代表 <code>Next-key Lock</code></li><li>INDEX_NAME：锁定索引的名称</li><li>LOCK_DATA：与锁相关的数据，比如锁在主键上就是主键值</li></ul><p>更多的字段解释参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual 26.12.12.1 The data_locks Table</a></p><p>除此之外，Mysql 还提供了查询当前正在执行的每个事务（不包括只读事务）的信息，比如隔离级别，内存中此事务的锁结构占用的总大小等等。语句如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX</span><br></pre></td></tr></table></figure><p>它提供几个关键信息：</p><ul><li>TRX_ID：如果是非锁定的只读事务是没有该 id 的</li><li>TRX_REQUESTED_LOCK_ID：当前事务正在等待的锁 id</li><li>TRX_TABLES_LOCKED：当前 SQL 语句具有行锁定的表的数量</li><li>TRX_LOCK_MEMORY_BYTES：内存中此事务的锁结构占用的总大小。</li><li>TRX_ISOLATION_LEVEL：当前事务的隔离级别</li></ul><p>更多的字段解释参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual 25.39.29 The INFORMATION_SCHEMA INNODB_TRX Table</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Mysql&lt;/code&gt; 的 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 语句是日常使用较多的用于锁定资源，确保在多个事务读取数据时始终能够读取到最新版本的数据的有效语句。那么它是怎么实现呢？在经过官网文档以及大量实践的验证之后发现网上存在大量不严谨甚至错误的信息，因此通过本文对 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 语句作出以下总结。在具体介绍之前，先对目前网上教程或博客中会提到的几个&lt;strong&gt;常见误区&lt;/strong&gt;进行纠正：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 在xx情况下会添加表级锁。&lt;/del&gt; &lt;/p&gt;
&lt;p&gt;请注意，&lt;strong&gt;在任何情况下 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 都不会添加表级锁。&lt;/strong&gt;事实上，在大部分情况下（DQL 语句，DML 语句，DDL 语句）都不会添加表锁，取而代之的是各种类型的行锁。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt; &lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;那么我们如何获取表锁呢？语句如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sql hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLES&lt;/span&gt; xx &lt;span class=&quot;hljs-keyword&quot;&gt;READ&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;# 为 xx 表添加表级 S 锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLES&lt;/span&gt; xx WRITE;  &lt;span class=&quot;hljs-comment&quot;&gt;# 为 xx 表添加表级 X 锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后我们可以通过以下语句来检测当前 Mysql 有哪些表获取了表级锁&lt;/p&gt;
&lt;figure class=&quot;highlight sql hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OPEN&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLES&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; In_use &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;更多的表级锁相关知识请参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html#table-lock-release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 在未使用索引时会”锁表”。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 确实可以通过 &lt;code&gt;Next-key lock&lt;/code&gt; 锁住所有记录和间隙来实现和表锁类似的效果。但未使用索引并非充分条件，我们判断 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 是否锁住了所有数据和间隙还需要看它的隔离级别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>基础同步工具类</title>
    <link href="http://yoursite.com/2019/02/11/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/11/基础同步工具类/</id>
    <published>2019-02-11T13:14:39.000Z</published>
    <updated>2020-02-06T03:58:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Semaphore，CountDownLatch，CyclicBarrier 均是 JDK1.5 提供的基础并发工具：</p><ul><li>Semaphore 是一个计数信号量，用于限制同时访问某个特定资源的数量</li><li>CountDownLatch 是一个闭锁，允许一个或多个线程等待一组其他线程执行完成后执行，但只能使用一次</li><li>CyclicBarrier 是一个循环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行，并且支持重复使用</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">10</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 方法本身控制同步</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title">getNextAvailableItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 信号量控制访问次数</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">markAsUnused</span><span class="hljs-params">(Integer item)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// do something</span></span><br><span class="line">        </span><br><span class="line">        semaphore.release();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Semaphore 的一个标准的使用方式，用于控制流量。上述程序创建了一个允许 10 个线程同时访问的信号量，并且使用公平锁（一般来说用于控制流量的使用需要使用公平模式，用于防止线程饥饿），然后在提供获取资源的接口 getNextAvailableItem 方法前先获取凭证，在释放资源后释放凭证。<strong>但是注意 Semaphore 不保证并发正确性，这需要接口自己保证，因此这里使用 synchronized 来提醒这一点。</strong></p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Semaphore 默认使用非公平锁，也可以显示的设置使用公平锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="hljs-keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="hljs-keyword">new</span> FairSync(permits) : <span class="hljs-keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁 FairSync 和非公平锁 NonfairSync 均继承于内部类 Sync，而 Sync 继承 AQS（AbstractQueuedSynchronizer）锁。获取锁和释放锁均在 Sycn 中实现</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire 在获取非公平锁的实现底层核心方法为 nonfairTryAcquireShared</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> available = getState();</span><br><span class="line">        <span class="hljs-keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="hljs-keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore 在初始化的时候会将 state 设为凭证数，在每次获取锁时 nonfairTryAcquireShared 会将 state - 1 直到 state 为 0，当 state 为 0 时则代表不可以再获取共享锁了。在具体实现上，这是一个标准的子类获取共享锁的实现模式。它本质是一个共享锁，会允许多个线程同时进入，因此在之前的使用介绍也提到了 Semaphore 不能确保并发正确性。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> available = getState();</span><br><span class="line">        <span class="hljs-keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="hljs-keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于公平模式的获取锁和 ReentrantLock 的实现相同，会先调用 hasQueuedPredecessors 来判断当前线程是否位于等待队列中的第一个，仅在处于队列的第一个时才会尝试获取锁，从而保证了获取锁的先后顺序。</p><p>还需要注意的是，无论是公平锁还是非公平锁，Semaphore 的acquire 是调用的 acquireSharedInterruptibly，因此它是可中断的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用不支持中断的，可以使用 acquireUninterruptibly</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> current = getState();</span><br><span class="line">        <span class="hljs-keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span></span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是调用 AQS 的释放共享锁的方法，那么本质上尝试释放锁就是通过重载 tryReleaseShared 实现的。因为共享锁的释放锁是存在并发的，所以需要通过 CAS 自旋更新 state 状态，每次释放都会将 state + 1。这也是一个标准的子类释放共享锁的实现模式。因此我们也要警惕使用 release，因为它会导致当前 state 大于凭证数，意味着如果释放次数大于获取次数会导致同时允许的线程数大于凭证数。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;There is no requirement that a thread that releases a permit must have acquired that permit by calling acquire(). Correct usage of a semaphore is established by programming convention in the application.</p><p>&emsp;&emsp;没有要求释放许可证的线程必须先通过调用 acquire() 获得该许可证。通过应用程序中的编程约定来建立信号量的正确使用。</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>了解了 Semaphore 原理后，这里通过 Semaphore 实现一个线程池只能同时执行两个任务的例子</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Task(semaphore, count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> AtomicInteger count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(Semaphore semaphore, AtomicInteger count)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="hljs-keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="hljs-string">"Semaphore 中断 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            doIt();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": is running ["</span> + count.addAndGet(<span class="hljs-number">1</span>) + <span class="hljs-string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep((<span class="hljs-keyword">int</span>)(<span class="hljs-number">1</span> + (Math.random() * <span class="hljs-number">3</span>)));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            count.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task 任务会在执行前先获取信号量，并对同时在运行的任务进行计数，在执行完任务后会重置计数并释放信号量。在实现过程中需要注意两个重要的点，也是实际使用时需要注意的点：</p><ol><li>doIt 执行任务本身需要保证并发安全，所以 count 使用 Atomic 类。</li><li>Semaphore 的 acquire 和 release 不要在同一个 try 中，否则当 acquire 获取失败时仍然会执行 release，而 release并不控制凭证数，这会导致有可能产生比设置时更大的 state</li></ol><p>在这个案例中，正常结果打印出来的同时运行的线程数不会超过 2，比如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2: is running [2]</span><br><span class="line">pool-1-thread-1: is running [1]</span><br><span class="line">pool-1-thread-3: is running [2]</span><br><span class="line">pool-1-thread-4: is running [2]</span><br><span class="line">pool-1-thread-2: is running [1]</span><br><span class="line">pool-1-thread-5: is running [2]</span><br><span class="line">pool-1-thread-1: is running [2]</span><br><span class="line">pool-1-thread-3: is running [1]</span><br><span class="line">pool-1-thread-4: is running [2]</span><br><span class="line">pool-1-thread-5: is running [2]</span><br></pre></td></tr></table></figure><blockquote><p><i class="far fa-bell"></i>   重点回顾</p><ul><li>Semaphore 底层通过 AQS 共享锁实现，支持公平/非公平模式</li><li>Semaphore 应用场景主要用于控制流量</li><li>Semaphore 并不保证并发正确性，需要接口本身保证</li><li>Semaphore 的 release 释放次数大于 acquire 获取次数时会导致并发数大于凭证数，因此这需要由调用者正确控制</li></ul></blockquote><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch startSignle = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">        CountDownLatch doneSignle = <span class="hljs-keyword">new</span> CountDownLatch(threadCnt);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Task(startSignle, doneSignle));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"All task start."</span>);</span><br><span class="line"></span><br><span class="line">        startSignle.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            doneSignle.await();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"All task done."</span>);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> CountDownLatch startSignle;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> CountDownLatch doneSignle;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(CountDownLatch startSignle, CountDownLatch doneSignle)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.startSignle = startSignle;</span><br><span class="line">        <span class="hljs-keyword">this</span>.doneSignle = doneSignle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            startSignle.await();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" is running"</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            doneSignle.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序创建了两个分别用于启动和结束的 CountDownLatch，startSignle 用于所有子线程等待主线程发送执行的信号，doneSignle 用于主线程等待所有子线程完成的信号。正常结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">All task start.</span><br><span class="line">pool-1-thread-2 is running</span><br><span class="line">pool-1-thread-3 is running</span><br><span class="line">pool-1-thread-4 is running</span><br><span class="line">pool-1-thread-1 is running</span><br><span class="line">pool-1-thread-5 is running</span><br><span class="line">pool-1-thread-4 is running</span><br><span class="line">pool-1-thread-1 is running</span><br><span class="line">pool-1-thread-2 is running</span><br><span class="line">pool-1-thread-5 is running</span><br><span class="line">pool-1-thread-3 is running</span><br><span class="line">All task done.</span><br></pre></td></tr></table></figure><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 的构造函数只有一个参数，用于控制 await 线程被执行前必须先执行线程的个数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 继承 AQS（AbstractQueuedSynchronizer）锁，因此 CountDownLatch 也是基于 AQS 的一个实现</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 调用的 acquireSharedInterruptibly 意味着它支持中断</p><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 的获取共享锁的方式和之前所说的 Semaphore 的实现对 state 的处理是完全相反的：</p><ul><li>在 Semaphore 中是在 state 大于 0 时允许获取锁</li><li>在 CountDownLatch 中是在 state = 0 时允许获取锁</li></ul><p>这很好理解，await 的线程需要在 N 个线程执行 countDown 后才允许被唤醒，和 Semaphore 的逻辑正好相反。</p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown 本质上就是释放共享锁，每次执行会将 state - 1 直到 0。在释放到 state = 0 后不会再释放。这就说明了两个问题：</p><ul><li>即使执行 countDown 的次数大于初始化时设置的 count 值也是不会有问题的，因为 releaseShared 会直接返回释放失败。</li><li>即使先执行 countDown，只要执行到足够的次数，再执行 await 也能成功获取到锁。</li></ul><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;为什么 await 方法获取锁成功是返回 1，而不是 0 呢？</p><p>&emsp;&emsp;这是因为在 AQS 中，释放共享锁后会唤醒后继结点，而后续的唤醒则依赖于获取锁的线程的传播式向后唤醒结点，而这依赖于 tryAcquireShared 的返回结果，当返回 0 时会被 AQS 认为无剩余共享资源导致无法唤醒后续结点。那么这就会导致最后一个 countDown 执行完后无法唤醒所有由 await 阻塞的线程</p></blockquote><p>最后那么我们来模拟多个线程等待多个线程执行完成后唤醒的过程：假设 A, B 两个线程等待 m, n 线程执行完成才能执行，而 A, B 先于 m, n 执行</p><ol><li>A 线程调用 await，因为 state 为 2 进入 AQS 等待队列，为头结点</li><li>B 线程调用 await，因为 state 为 2 进入 AQS 等待队列，插入队尾</li><li>m 线程调用 countDown，将 state 设为 1，释放锁成功，尝试唤醒 A，A 尝试获取锁但因为 state != 0，唤醒失败</li><li>n 线程调用 countDown，将 state 设为 0，释放锁成功，尝试唤醒 A，A 尝试获取锁因为 state = 0，A 唤醒成功</li><li>A 获取锁成功返回 1 允许传播式尝试唤醒 B，B 尝试获取锁因为 state = 0，B 唤醒成功</li></ol><blockquote><p><i class="far fa-bell"></i>   重点回顾</p><ul><li>CountDownLatch 底层通过 AQS 共享锁实现</li><li>CountDownLatch 的应用场景为一个或多个线程等待一组其他线程执行完成后执行</li><li>CountDownLatch 的 countDown 次数大于初始化时设置的 count 值时会抛出异常</li><li>CountDownLatch 的 countDown 方法可以先于 await 方法先执行</li></ul></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(threadCnt);</span><br><span class="line"></span><br><span class="line">        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Task(cyclicBarrier, threadCnt * <span class="hljs-number">2</span>, count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"All tasks done."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> AtomicInteger count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer taskCnt;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(CyclicBarrier cyclicBarrier, Integer taskCnt, AtomicInteger count)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="hljs-keyword">this</span>.taskCnt = taskCnt;</span><br><span class="line">        <span class="hljs-keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">while</span> (!isDone())&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" starts."</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">                count.addAndGet(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" is waiting."</span>);</span><br><span class="line"></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" quit."</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> taskCnt.equals(count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序创建了一个需要 5 个线程到达后每个线程才能执行后续流程的循环栅栏 CyclicBarrier。每个任务执行完毕后会将 count + 1 以及通过 await 等待其他线程完成。而每个线程完成所有任务的标志是 count = 10，因此在前 5 个执行完成后又会重复的执行一轮，最后全部线程退出。正常结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 starts.</span><br><span class="line">pool-1-thread-5 starts.</span><br><span class="line">pool-1-thread-4 starts.</span><br><span class="line">pool-1-thread-3 starts.</span><br><span class="line">pool-1-thread-1 starts.</span><br><span class="line">pool-1-thread-5 is waiting.</span><br><span class="line">pool-1-thread-4 is waiting.</span><br><span class="line">pool-1-thread-3 is waiting.</span><br><span class="line">pool-1-thread-1 is waiting.</span><br><span class="line">pool-1-thread-2 is waiting.</span><br><span class="line">pool-1-thread-2 starts.</span><br><span class="line">pool-1-thread-5 starts.</span><br><span class="line">pool-1-thread-4 starts.</span><br><span class="line">pool-1-thread-3 starts.</span><br><span class="line">pool-1-thread-1 starts.</span><br><span class="line">pool-1-thread-4 is waiting.</span><br><span class="line">pool-1-thread-1 is waiting.</span><br><span class="line">pool-1-thread-5 is waiting.</span><br><span class="line">pool-1-thread-3 is waiting.</span><br><span class="line">pool-1-thread-2 is waiting.</span><br><span class="line">pool-1-thread-2 quit.</span><br><span class="line">pool-1-thread-4 quit.</span><br><span class="line">pool-1-thread-3 quit.</span><br><span class="line">pool-1-thread-1 quit.</span><br><span class="line">pool-1-thread-5 quit.</span><br><span class="line">All tasks done.</span><br></pre></td></tr></table></figure><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;CyclicBarrier 结合线程池使用需要注意死锁问题，当线程池可执行线程数小于 CyclicBarrier 触发栅栏的线程时会产生死锁</p></blockquote><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CyclicBarrier 存在两个构造函数，parties 用于执行在触发栅栏之前需要执行的线程数，barrierAction 为触发栅栏的线程首先执行该任务后才会唤醒所有等待的线程</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="hljs-keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="hljs-keyword">this</span>.count = parties;</span><br><span class="line">    <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> dowait(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(toe); <span class="hljs-comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dowait</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="hljs-function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 当前代</span></span><br><span class="line">        <span class="hljs-keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (g.broken)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> index = --count;</span><br><span class="line">        <span class="hljs-comment">// 当index=0时代表触发栅栏</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span></span><br><span class="line">            <span class="hljs-keyword">boolean</span> ranAction = <span class="hljs-keyword">false</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 首先执行传入的任务</span></span><br><span class="line">                <span class="hljs-keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="hljs-keyword">if</span> (command != <span class="hljs-keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="hljs-keyword">true</span>;</span><br><span class="line">                <span class="hljs-comment">// 然后更新代，唤醒所有等待线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 如果还没触发栅栏，则阻塞</span></span><br><span class="line">        <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 如果未设置超时时间，则直接阻塞</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="hljs-comment">// 否则对阻塞设置超时时间</span></span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="hljs-keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="hljs-comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (g.broken)</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (g != generation)</span><br><span class="line">                <span class="hljs-keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 是一个可以循环使用的栅栏，因此它有一个“代”的概念，即每个在触发栅栏之前需要执行的线程数为一代，每执行一次任务则会将需要执行的线程数减一直到 0，这时候就进入了新的一代，即新的循环。 await 实际上通过 ReentrantLock + Condition 完成线程的阻塞和唤醒：</p><ol><li><p>判断当前线程在当前代中的位置，如果还不能触发栅栏，则调用 condition.await/awaitNanos 对当前线程进行阻塞</p></li><li><p>如果一个线程触发了栅栏，首先执行传入的 Runnable 任务，然后唤醒所有等待的任务，再更新代</p></li><li><p>每个被唤醒的线程检查当前代是否已经更新，如果已经更新，则返回在阻塞时还剩余需要执行的线程数。因此  <code>barrier.await() == 0</code>  时意味着当前代需要执行的最后一个线程已完成，可以做些一轮任务做完需要做的工作，比如整合，日志等</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (barrier.await() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// log the completion of this iteration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它和 barrierAction 还是有些区别，barrierAction 中执行的内容会在唤醒其他线程前执行（新代执行前），而 <code>barrier.await() == 0</code> 内执行的内容则是在唤醒其他线程后执行的（有可能新代已经开始执行），因此在使用时需要多加考虑</p></li></ol><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;CountDownLatch 和 CyclicBarrier 比较相似，都是多个线程相互等待后执行，但它们还是有比较大的区别：</p><ol><li>从实现来看，CountDownLatch 使用的是共享锁，所以一次 countDown 能唤醒所有 await 等待的线程；而 CyclicBarrier 使用的互斥锁 + Condition 的方式，由调用 await 触发栅栏的线程来唤醒一个代中的所有线程（signAll）</li><li>从功能来看，CountDownLatch 只允许使用一次，而 CyclicBarrier 允许循环使用</li><li>从应用来看，CountDownLatch 适用于一个或多个线程等待一组线程执行完成后执行，比如初始化；而 CyclicBarrier 适合用于一组线程相互之间等待，达到一个共同点，再继续执行。比如并行计算，计算中涉及多个子任务阶段式完成任务</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Semaphore，CountDownLatch，CyclicBarrier 均是 JDK1.5 提供的基础并发工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Semaphore 是一个计数信号量，用于限制同时访问某个特定资源的数量&lt;/li&gt;
&lt;li&gt;CountDownLatch 是一个闭锁，允许一个或多个线程等待一组其他线程执行完成后执行，但只能使用一次&lt;/li&gt;
&lt;li&gt;CyclicBarrier 是一个循环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行，并且支持重复使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h2&gt;&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;X&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Random random = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Semaphore semaphore = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Semaphore(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 方法本身控制同步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;getNextAvailableItem&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// 信号量控制访问次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore.acquire();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; random.nextInt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;markAsUnused&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Integer item)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore.release();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是 Semaphore 的一个标准的使用方式，用于控制流量。上述程序创建了一个允许 10 个线程同时访问的信号量，并且使用公平锁（一般来说用于控制流量的使用需要使用公平模式，用于防止线程饥饿），然后在提供获取资源的接口 getNextAvailableItem 方法前先获取凭证，在释放资源后释放凭证。&lt;strong&gt;但是注意 Semaphore 不保证并发正确性，这需要接口自己保证，因此这里使用 synchronized 来提醒这一点。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://yoursite.com/2019/01/14/ReentrantLock/"/>
    <id>http://yoursite.com/2019/01/14/ReentrantLock/</id>
    <published>2019-01-14T11:53:12.000Z</published>
    <updated>2020-02-06T05:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;ReentrantLock 是基于 AQS 同步器实现的互斥锁，它支持设置公平锁/非公平锁模式，同时具有可重入性。在这里讨论 ReentrantLock 对这些特性的支持及应用。</p><h2 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        lock.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// ... method body</span></span><br><span class="line">        </span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ReentrantLock 默认使用非公平锁，也可以通过显式的使用公平锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="hljs-keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁 FairSync 和非公平锁 NonfairSync 均继承于内部类 Sync，而 Sync 继承 AQS（AbstractQueuedSynchronizer）锁。获取锁和释放锁均在 Sycn 中实现</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="hljs-comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span></span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的 <a href="http://zzcoder.cn/2019/01/10/AbstractQueuedSynchronizer%E5%90%8C%E6%AD%A5%E5%99%A8/" target="_blank" rel="noopener">AQS同步器</a> 提到过，AbstractQueuedSynchronizer 为子类提供了需要实现的 tryAcquire 模板方法，非公平锁获取锁调用的底层核心方法是 nonfairTryAcquire。首先基于 AQS 实现获取互斥锁的标准实现：<strong>当 state 为 0 时代表没有线程持有锁，因此尝试获取锁，如果获取锁成功则将当前线程设为持有锁的线程</strong>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> c = getState();</span><br><span class="line"><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但和普通的互斥锁不同的是，ReentrantLock 还需要支持可重入性：<strong>当 state 不为 0（即存在线程持有锁），会继续判断持有锁的是否为当前线程，如果是则允许当前线程获取锁，并将 state + 1。</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span></span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么释放逻辑也需要对重入性额外处理</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        free = <span class="hljs-keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="hljs-keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先确保释放锁的线程为持有锁的线程，接下去确保重入次数和释放次数相同（即 state = 0）才认为释放锁完成，才会将持有锁的线程设为空。</strong></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;ReentrantLock 的非公平锁模式意味着多个线程获取锁的顺序并不是按照申请锁的顺序，会存在“线程饥饿”的问题</p></blockquote><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="hljs-comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 先判断当前线程是否位于等待队列中的第一个</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁唯一的区别在于，它通过 hasQueuedPredecessors 确保当前线程是否位于等待队列中的第一个时才会尝试竞争锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="hljs-comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="hljs-comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="hljs-keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么也就是说<strong>公平模式的获取锁会先判断当前线程是否位于等待队列中的第一个，若不是则直接加入等待队列来确保多个线程按照申请锁的顺序来获取锁</strong></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;公平模式可以解决线程饥饿问题，但相比非公平模式，也会使得更多的线程阻塞，产生更多 CPU 唤醒阻塞线程的开销而影响吞吐量</p></blockquote><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition 是一个多线程间协调通信工具类，在 AQS 中实现，子类可以创建 Condition 实现类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 添加到 Condition 队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 释放锁</span></span><br><span class="line">    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 判断是否在 AQS 队列，如果不在则阻塞</span></span><br><span class="line">    <span class="hljs-comment">// 唤醒时会将当前线程重新插入 AQS 队列尾</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="hljs-keyword">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 自旋获取锁直到重新阻塞</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition 存在自己的队列，在 Condition 队列就意味着线程需要 signal 方法唤醒。await 方法主要做以下几步：</p><ol><li>将当前线程加入 Condition 队列尾</li><li>释放锁，即从 AQS 队列中退出（因此线程不会同时存在于 AQS 队列和 Condition 队列）</li><li>阻塞当前线程等待唤醒（唤醒时会将当前线程重新插入 AQS 队列尾，然后当它的前驱结点释放锁后 unpark 唤醒，唤醒后自旋/阻塞获取锁）</li></ol><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 确保当前线程持有锁</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 将 Condition 队列中的首结点加入 AQS 队列</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal 方法用于唤醒处于 Condition 队列中的首结点，但注意它并不是立刻唤醒</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 移除头结点</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="hljs-keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 仅在前驱节点的状态处于取消状态或设置前驱节点状态为 SIGNAL 失败时才会直接唤醒</span></span><br><span class="line">    <span class="hljs-comment">// 大部分情况都不会在这里唤醒</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal 方法的主要逻辑如下：</p><ol><li>首先它会将头结点从 Condition 队列取出</li><li>然后通过 enq 将当前线程加入 AQS 队列尾</li><li>仅在前驱节点的状态处于取消状态或设置前驱节点状态为 SIGNAL 失败时才会直接唤醒，否则是等待它在 AQS 队列的前驱结点释放锁后唤醒（这样它的前驱结点为头结点，它才有资格获取锁，唤醒才有意义）</li></ol><h3 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signalAll 和 signal 的区别就在于它会遍历 Condition 队列，把所有 Condition 队列中的结点放入 AQS 队列等待唤醒。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>一个经典的应用：生产者/消费者模式</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Random;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer max;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProducerConsumer</span><span class="hljs-params">(Queue&lt;Integer&gt; queue, Integer max)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="hljs-keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">while</span> (queue.size() &gt;= max) &#123;</span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            full.await();</span><br><span class="line">                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">int</span> num = random.nextInt();</span><br><span class="line">                    <span class="hljs-keyword">if</span>(queue.size() &gt;= max) &#123;</span><br><span class="line">                        <span class="hljs-keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(num);</span><br><span class="line">                    empty.signalAll();</span><br><span class="line">                &#125;<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="hljs-string">"Not safe"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(;;) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;                </span><br><span class="line">                            empty.await();</span><br><span class="line">                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    full.signalAll();</span><br><span class="line">                &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">int</span> max = <span class="hljs-number">10</span>;</span><br><span class="line">      </span><br><span class="line">        ProducerConsumer producerConsumer = <span class="hljs-keyword">new</span> ProducerConsumer(queue, max);</span><br><span class="line">        producerConsumer.produce();</span><br><span class="line">        producerConsumer.produce();</span><br><span class="line">        producerConsumer.consume();</span><br><span class="line">        producerConsumer.consume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况，不会出现 <code>Not safe</code></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;Synchronized + wait/notify 的组合和 Lock + Condition 组合具有类似的功能，性能上的差别也不是很大，但它们仍然有许多区别。这里举几个典型的例子：</p><ul><li>Lock + Condition 可以选择公平/非公平模式，而 Synchronized + wait/notify 只能是非公平的</li><li>Lock + Condition 可以唤醒指定 Condition，而 Synchronized + wait/notify 不能指定</li><li>Lock + Condition 可以设置超时时间，而 Synchronized + wait/notify 只能等待唤醒或中断</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;ReentrantLock 是基于 AQS 同步器实现的互斥锁，它支持设置公平锁/非公平锁模式，同时具有可重入性。在这里讨论 ReentrantLock 对这些特性的支持及应用。&lt;/p&gt;
&lt;h2 id=&quot;标准模式&quot;&gt;&lt;a href=&quot;#标准模式&quot; class=&quot;headerlink&quot; title=&quot;标准模式&quot;&gt;&lt;/a&gt;标准模式&lt;/h2&gt;&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;X&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;// ... method body&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lock.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步器</title>
    <link href="http://yoursite.com/2019/01/10/AbstractQueuedSynchronizer%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>http://yoursite.com/2019/01/10/AbstractQueuedSynchronizer同步器/</id>
    <published>2019-01-10T11:53:57.000Z</published>
    <updated>2020-02-06T05:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。</p><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p>AbstractQueuedSynchronizer 内部维护着一个 FIFO 的 CLH 队列，队列中的每个 Node 代表着一个需要获取锁的线程</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png" alt=""></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;自旋锁：自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是立刻进入线程挂起或睡眠状态。</p><ul><li>CLH 锁（Craig, Landin, and Hagersten  locks）：基于链表的可扩展、高性能、公平的自旋锁，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋</li><li>MCS 锁：在当前结点自旋，但由前驱结点通知其结束自旋</li></ul></blockquote><p>AQS 采用的是一种变种的 CLH 队列锁：原始 CLH 是在前驱结点自旋，通过判断 pred.locked 来自旋，而 <strong>AQS 的 CLH 则是根据前驱结点的状态来控制阻塞，不会一直自旋。同时当前驱结点释放锁时会去唤醒该结点使其参与竞争锁。</strong> AQS 的结点的定义如下：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 指向 Condition 队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 结点中分别有指向前驱，后继的结点，入队时的线程以及结点状态（Condition 队列本文不涉及）。结点状态会存在以下几种：</p><ul><li>CANCELLED：线程取消</li><li>SIGNAL：当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程</li><li>CONDITION：在等待 Condition ，也就是在 Condition 队列中</li><li>PROPAGATE：当头结点处于 PROPAGATE，需要唤醒后继线程，为了保证共享模式下唤醒机制正常</li><li>0：初始状态</li></ul><p>基于上述 Node 的定义，AQS 基本属性如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 队列的头结点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 队列的尾节点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 同步状态</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>AbstractQueuedSynchronizer 的提供的接口主要有两种类型</p><h3 id="控制同步状态"><a href="#控制同步状态" class="headerlink" title="控制同步状态"></a>控制同步状态</h3><p>AbstractQueuedSynchronizer 并不实现同步接口，所有对同步状态的控制都交由子类同步组件控制。比如 tryAcquire 代表由子类控制当前线程是否能独占式获取同步状态成功</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>boolean tryRelease(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>共享式释放同步状态</td></tr><tr><td>boolean isHeldExclusively()</td><td>检测当前线程是否获取独占锁</td></tr></tbody></table><p>而在多线程环境中对状态的操纵必须确保原子性，因此它还提供了对状态控制的三组 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getState()</td><td>获取同步状态</td></tr><tr><td>void setState()</td><td>设置同步状态</td></tr><tr><td>boolean compareAndSetState(int expect, int update)</td><td>通过 CAS 设置同步状态</td></tr></tbody></table><p>通过这三组 API，子类可以线程安全的控制同步状态（同时子类需要确保实现是非阻塞的）</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>模板方法封装了获取同步状态成功或失败后的在队列中的一系列操作，子类可以直接调用</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态，该方法将会调用 tryAcquire 尝试获取同步状态。获取成功则返回，获取失败，线程进入同步队列等待。</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>响应中断版的 acquire</td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>超时 + 响应中断版的 acquire</td></tr><tr><td>void acquireShared(int arg)</td><td>共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如读写锁的读锁就是就是调用这个方法获取同步状态的。</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>响应中断版的 acquireShared</td></tr><tr><td>boolean tryAcquireSharedNanos(int arg,long nanos)</td><td>超时 + 响应中断版的 acquireShared</td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>boolean releaseShared(int arg)</td><td>共享式释放同步状态</td></tr></tbody></table><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法代表尝试获取一次互斥锁，需要子类根据需求去实现（比如 ReentrantLock 实现了公平锁和非公平锁），通过布尔变量来标志获取状态：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若获取失败，则通过 addWaiter 方法将当前线程添加至阻塞队列</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 将线程封装在Node节点中</span></span><br><span class="line">    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// CAS 尝试将该节点插在队列尾</span></span><br><span class="line">    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="hljs-keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果不成功则通过自旋的方式插到队尾，直到插入成功</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="hljs-keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="hljs-comment">// 设置头结点，初始情况下，头结点是一个空结点(这里不会直接返回，因此即使阻塞队列为空，当前节点仍然是插在空结点之后)</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="hljs-comment">// 插入该结点到队尾</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="hljs-keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入完成后，则会调用 acquireQueued() 方法对该结点进行有限次自旋获取锁，并在到达边界条件后阻塞</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="hljs-comment">// 如果该节点的前一节点为头节点，那么它将有资格参与竞争锁</span></span><br><span class="line">            <span class="hljs-comment">// 如果获取锁成功，则将当前结点设为头结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span></span><br><span class="line">                failed = <span class="hljs-keyword">false</span>;</span><br><span class="line">                <span class="hljs-keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-comment">// 判断线程需不需要阻塞，和 CLH 不同，线程并不总是参与竞争锁，而是仅当线程被唤醒时竞争锁</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="hljs-comment">// 如果前驱节点为 SIGNAL 状态，那么在释放锁时会唤醒后继结点</span></span><br><span class="line">    <span class="hljs-comment">// 因此这种情况当前结点会阻塞自己</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果前驱节点为 CANCELLED 状态，那么从后向前找到第一个非取消状态的节点</span></span><br><span class="line">    <span class="hljs-comment">// 并更新当前结点的前驱为该结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 如果前驱节点为 0 或 PROPAGATE，那么设置前驱结点的状态为 SIGNAL（可以说这一步才是标志会将每一个节点阻塞的一步）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// LockSupport.park(this) 来挂起线程，然后就停在这里了，等待被唤醒</span></span><br><span class="line"><span class="hljs-comment">// 返回的时候会先判断是否由线程中断造成的，如果由线程中断造成，在这里会接下去置中断标记</span></span><br><span class="line"><span class="hljs-comment">// 而 lockInterruptibly 方法则是抛出异常</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span>  <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么总结下 acquire 方法的逻辑：</p><ol><li>尝试获取互斥锁，若获取成功则直接返回</li><li>若获取失败，则将当前线程添加到阻塞队列尾（CAS 操作插入，自旋直到插入成功为止）</li><li>自旋/阻塞获取锁<ol><li>尝试获取互斥锁（前驱结点必须为头结点时，当前结点才有资格竞争锁），若获取成功则将当前结点设为头结点后退出</li><li>若前驱结点为 SIGNAL 状态，则阻塞当前结点（唤醒后继续循环 <em>自旋/阻塞获取锁</em> ）</li><li>若前驱结点为 CANCELLED 状态，则更新前驱到非取消结点</li><li>若前驱结点为 0 或 PROPAGATE，则设置前驱结点状态为 SIGNAL 状态</li></ol></li></ol><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// h == null 的情况就是阻塞队列为空（前面说过，第一个线程持有锁时不会放到头结点中）</span></span><br><span class="line">        <span class="hljs-comment">// h.waitStatus = 0，那么其后的结点必定没有阻塞（前面也说过，因为该值是由后继结点来赋值的，然后仅当该结点状态为阻塞状态，后继结点才会将自己阻塞，即 CLH 特性，根据前驱结点状态来控制自己）</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease 方法代表尝试释放一次互斥锁，需要子类根据需求去实现，通过布尔变量来标志获取状态：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放锁成功后，会判断当前结点状态来唤醒后继结点，即当前结点状态为 SIGNAL 状态时会唤醒后继结点</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)</span><br><span class="line">    unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-comment">// 设置头结点状态为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 从队尾往前找，找到 waitStatus &lt;= 0 的所有节点中排在最前面的(&gt; 0 代表节点取消阻塞)</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        s = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 唤醒该节点，也就是头结点的下一个不为取消阻塞状态的节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么总结下 release 方法的逻辑：</p><ol><li>尝试释放一次互斥锁，若释放失败，则直接返回失败</li><li>释放成功后，唤醒一个后继结点</li></ol><h2 id="互斥锁案例"><a href="#互斥锁案例" class="headerlink" title="互斥锁案例"></a>互斥锁案例</h2><p>通过以上的理解，可以实现一个简单的互斥锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutexLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sync</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            setState(<span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))&#123;</span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> release)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);</span><br><span class="line">            setState(<span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.release(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类 Sync 继承 AbstractQueuedSynchronizer，并重载 tryAcquire 和 tryRelease 方法</p><ul><li>tryAcquire 通过 CAS 尝试获取一次同步状态（0 -&gt; 1），若获取成功则设置当前持有锁的线程为自己</li><li>tryRelease 判断同步状态是否为 1，若是则重置同步状态为 0，且设置当前获取锁的线程为 null，否则抛出异常（互斥锁的释放不会有并发）</li></ul><p>我们可以写个简单的并发计数测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 计数</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> Mutex mutex = <span class="hljs-keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        count = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++)&#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                        mutex.lock();</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                            mutex.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"assert "</span> + threadCnt * <span class="hljs-number">10000</span> + <span class="hljs-string">" = "</span> + count + <span class="hljs-string">" is true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常输出为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 100000 = 100000 is true</span><br></pre></td></tr></table></figure><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquireShared 方法尝试获取一次共享锁，需要子类根据需求去实现。但和互斥锁不同的是，它以整型作为状态标志，负数代表获取失败，非负数代表获取成功，0 代表成功但之后的竞争线程不会成功</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取共享锁失败时，会调用 doAcquireShared 将当前线程添加至阻塞队列并自旋获取共享锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 将当前线程添加至阻塞队列</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="hljs-comment">// 如果该节点的前一节点为头节点，那么它将有资格参与竞争锁</span></span><br><span class="line">            <span class="hljs-comment">// 如果获取锁成功，则将当前结点设为头结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-comment">// 和互斥锁不同的点，共享锁会在获取锁成功后唤醒后继结点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 判断线程需不需要阻塞</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的大体逻辑和互斥锁的自旋获取锁逻辑相同，但是它们之间有个很重要的不同点，即共享锁在获取锁成功后调用 setHeadAndPropagate 来唤醒后继结点</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="hljs-comment">// Record old head for check below</span></span><br><span class="line">    <span class="hljs-comment">// 设为头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 唤醒后继结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="hljs-comment">// 如果头结点处于 SIGNAL 状态，唤醒后继结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 如果头结点处于 0 的状态，设置头结点状态为 PROPAGATE</span></span><br><span class="line">            <span class="hljs-comment">// 这是为了解决共享锁的并发唤醒后继结点导致极端情况下存在线程永远无法唤醒的情况</span></span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))</span><br><span class="line">            <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断是否需要唤醒后继结点这步，它的判断逻辑是 propagate &gt; 0 || h.waitStatus &lt; 0：</p><ul><li>propagate &gt; 0 ：tryAcquireShared 方法的返回值，代表当前线程获取共享锁成功（按理说 propagate = 0 的情况也属于获取锁成功，为什么不加进去呢？这是因为当 propagate = 0 时代表当前已经没有共享资源了，所以唤醒也没有意义了）</li><li>h.waitStatus &lt; 0 ：头结点状态为 SIGNAL 或 PROPAGATE 时</li></ul><blockquote><p><i class="far fa-bell"></i> </p><p>&emsp;&emsp;在共享锁中会存在 PROPAGATE 状态：</p><ul><li><p>获取共享锁成功后，如果头结点状态为 0（unparkSuccessor 时会将头结点状态设为0），会将头结点状态设为 PROPAGATE</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">​    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))</span><br><span class="line">​    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span></span><br></pre></td></tr></table></figure></li><li><p>判断后继结点是否需要唤醒时会判断头结点的状态 propagate &gt; 0 || h.waitStatus &lt; 0</p></li></ul><p>之所以需要这个状态是因为共享锁的 <em>唤醒后继结点</em>  操作是并发操作，同时 propagate = 0 的情况不会唤醒后继结点，因此在一些极端情况下会存在阻塞结点无法被唤醒的情况</p></blockquote><p>那么我们总结下获取共享锁的逻辑：</p><ol><li>尝试获取共享锁，若获取成功则直接返回</li><li>若获取失败，则将当前线程添加到阻塞队列尾（CAS 操作插入，自旋直到插入成功为止）</li><li>自旋/阻塞获取锁<ol><li>尝试获取共享锁（前驱结点必须为头结点时，当前结点才有资格竞争锁），若获取成功则尝试唤醒一个<strong>后继结点</strong>（唤醒的结点如果获取锁成功又会继续唤醒接下去的结点）</li><li>前驱结点为 SIGNAL 状态，则阻塞当前结点（唤醒后继续循环 <em>自旋/阻塞获取锁</em> ）</li><li>前驱结点为 CANCELLED 状态，则更新前驱到非取消结点</li><li>前驱结点为 0 或 PROPAGATE，则设置前驱结点状态为 SIGNAL 状态</li></ol></li></ol><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 方法代表尝试释放一次共享锁，需要子类根据需求去实现，通过布尔变量来标志获取状态：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放成功后会调用 doReleaseShared 尝试唤醒一个后继结点，上面已经解释了。</p><h2 id="共享锁案例"><a href="#共享锁案例" class="headerlink" title="共享锁案例"></a>共享锁案例</h2><p>基于以上分析，我们也可以实现一个同时允许 N 个线程进入的共享锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShareLock</span><span class="hljs-params">(Integer permit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(permit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="hljs-keyword">int</span> permit)&#123;</span><br><span class="line"></span><br><span class="line">            setState(permit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> expect = getState();</span><br><span class="line">                <span class="hljs-keyword">int</span> update = expect - acquire;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(update &lt; <span class="hljs-number">0</span> || compareAndSetState(expect, update))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">return</span> update;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> release)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> expect = getState();</span><br><span class="line">                <span class="hljs-keyword">int</span> update = expect + release;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(compareAndSetState(expect, update))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireShared(<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对共享锁进行简单的测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> ShareLock shareLock = <span class="hljs-keyword">new</span> ShareLock(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++)&#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    shareLock.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": is running"</span>);</span><br><span class="line"></span><br><span class="line">                        Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                        shareLock.unlock();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序创建了一个允许最多两个线程同时进入的共享锁。因此正常情况下，日志会成双打印。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul><li>thread.interrupt()：中断线程，将会设置该线程的中断状态位，即设置为 true（<strong>不会中断一个正在运行的线程，而是中断阻塞的线程</strong>）</li><li>thread.interrupted()：判断某个线程是否已被发送过中断请求，该方法调用后会将中断标示位清除，即重新设置为 false</li><li>Thread.currentThread().isInterrupted()：判断某个线程是否已被发送过中断请求，不会将中断标示位清除</li></ul><p>如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait、1.5 中的 condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 InterruptedException 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为 false。而如果线程处于非阻塞状态，则需要通过判断 Thread.interrupted() 或者 Thread.isInterrupted() 来循环检测</p><blockquote><p><i class="far fa-bell"></i> </p><ol><li><p>Synchronized 在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断</p></li><li><p>LockSupport 的 park 方法阻塞，能够响应中断，但是不会抛出 InterruptedException 异常</p></li><li><p>一个支持中断线程的程序的标准处理模式</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">​    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="hljs-comment">// do something</span></span><br><span class="line"></span><br><span class="line">​        <span class="hljs-comment">// 1. !Thread.currentThread().isInterrupted() 确保在非阻塞时能响应中断</span></span><br><span class="line">​        <span class="hljs-comment">// 2. try-catch 后对 InterruptedException 处理确保阻塞时对中断进行处理</span></span><br><span class="line">​        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="hljs-keyword">do</span>) &#123;</span><br><span class="line">​            <span class="hljs-keyword">do</span> more work </span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">​        <span class="hljs-comment">//线程在 wait 或 sleep 期间被中断了</span></span><br><span class="line">​    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">​        <span class="hljs-comment">//线程结束前做一些清理工作</span></span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>在之前所说的 acquire，ascquireShared 方法均不支持中断操作</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>它们在 LockSupport.park 响应中断后只是置一个中断标记，但是并不会处理，仍然自旋获取锁直到获取成功或阻塞。而 acquireInterruptibly，acquireSharedInterruptibly 方法支持中断操作</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure><p>它们会在 LockSupport.park 响应中断后抛出 InterruptedException 异常结束线程</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000014721183" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li><li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></li><li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。&lt;/p&gt;
&lt;h2 id=&quot;AQS简介&quot;&gt;&lt;a href=&quot;#AQS简介&quot; class=&quot;headerlink&quot; title=&quot;AQS简介&quot;&gt;&lt;/a&gt;AQS简介&lt;/h2&gt;&lt;p&gt;AbstractQueuedSynchronizer 内部维护着一个 FIFO 的 CLH 队列，队列中的每个 Node 代表着一个需要获取锁的线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt; 
&lt;p&gt;&amp;emsp;&amp;emsp;自旋锁：自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是立刻进入线程挂起或睡眠状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CLH 锁（Craig, Landin, and Hagersten  locks）：基于链表的可扩展、高性能、公平的自旋锁，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋&lt;/li&gt;
&lt;li&gt;MCS 锁：在当前结点自旋，但由前驱结点通知其结束自旋&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;AQS 采用的是一种变种的 CLH 队列锁：原始 CLH 是在前驱结点自旋，通过判断 pred.locked 来自旋，而 &lt;strong&gt;AQS 的 CLH 则是根据前驱结点的状态来控制阻塞，不会一直自旋。同时当前驱结点释放锁时会去唤醒该结点使其参与竞争锁。&lt;/strong&gt; AQS 的结点的定义如下：&lt;/p&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="http://yoursite.com/2018/12/22/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://yoursite.com/2018/12/22/内存屏障/</id>
    <published>2018-12-22T14:17:33.000Z</published>
    <updated>2020-02-06T04:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;现代计算机大多数采用多核处理器或多处理器以提高性能，同时每个处理器通常存在一层或多层高速缓存，这将会更进一步加快对数据的访问。但是这也带来了新的挑战，即同一数据在不同处理器之间并不保证一致。所以为了保证数据的可见性，内存屏障应运而生。它能够刷新或使本地处理器高速缓存失效，以便查看其他处理器进行的写入的最新值或使该处理器的写入对其他处理器可见。而 Java 内存模型用于屏蔽不同硬件所带来的内存访问差异，以实现程序在不同平台能保证一致的并发效果。那么在并发环境下如何正确的使用内存屏障成为了首要问题。</p><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p>Java 内存模型是对硬件内存模型的抽象，因此理解它需要一些硬件基础知识。这里主要介绍 <strong>处理器的存储器结构</strong> 和 <strong>处理器的高速缓存与缓存一致性</strong></p><h3 id="随机访问存储器（RAM）"><a href="#随机访问存储器（RAM）" class="headerlink" title="随机访问存储器（RAM）"></a>随机访问存储器（RAM）</h3><p>随机访问存储器（RAM），是用于和 CPU 交换数据的内部存储器。根据存储单元的工作原理不同可以分为两类：</p><ul><li>动态的存储器（DRAM）</li><li>静态的存储器（SRAM）</li></ul><p>SRAM 比 DRAM 更快，但也更贵，因此 SRAM 主要作为高速缓存存储器（Cache，如 CPU 的 L1，L2），而 DRAM 则作为计算机主存。而我们常说的内存指的就是是计算机的主内存 DRAM。</p><a id="more"></a><h3 id="总线（Bus）"><a href="#总线（Bus）" class="headerlink" title="总线（Bus）"></a>总线（Bus）</h3><p>总线是一组并行的导线，能携带地址，数据和控制信号，用于计算机各种功能部件（CPU，DRAM，I/O 设备等）之间传送信息。根据传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线。<strong>CPU 则是通过数据总线与内存交换数据的（即通信）</strong></p><blockquote><p>CPU 和主存（DRAM）之间的数据传送称为总线事务，读事务代表从主存传送数据到 CPU，写事务代表从 CPU 传送数据到主存。</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/bus.png" alt=""></p><p>它们同个两条总线连接起来，一条是系统总线（连接 CPU 和 I/O 桥接器），一条是内存总线（连接 I/O 桥接器和 DRAM），其中 I/O 桥接器会将系统总线的电子信号翻译成内存总线的电子信号。</p><ul><li><p>读事务（movq A, %rax）：</p><ul><li>首先 CPU 将地址 A 放到系统总线并通过 I/O 桥传递到内存总线</li><li>接着 DRAM 感受到内存总线的地址信号并读取地址，并将其对应的数据写回内存总线通过 I/O 桥传递到系统总线</li><li>最后 CPU 感觉到系统总线的数据并读取数据复制到寄存器中完成读事务。</li></ul><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/bus-read-trans.png" alt=""></p></li><li><p>写事务（movq %rax, A）：</p><ul><li>首先 CPU 将地址 A 放到系统总线，DRAM 从内存总线读出地址，并等到数据到达</li><li>接着，CPU 将寄存器中的 %rax 放到系统总线</li><li>最后，DRAM 从内存总线读出数据，并存储到 DRAM 中</li></ul><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/bus-write-trans.png" alt=""></p></li></ul></blockquote><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p>以一个经典的存储器层次结构举例，所有现代计算机系统都是采用这种结构</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/memory-hierarchy.png" alt=""></p><p>从上至下，存储设备的速度变得更慢，容量更大。顶层是最快的寄存器，CPU 可以在一个时钟周期内访问，接下来是 L1 - L3 缓存（它们用的就是之前所说的 SRAM），然后就是计算机主存（DRAM），再往下就是磁盘等等。</p><p>而 Inter Core i7 中的高速缓存如下：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/intel-core-i7.png" alt=""></p><p>Intel Core i7 处理器的的每个 CPU 芯片有 4 个核。每个核有自己私有的 L1，L2 高速缓存，所有的核共享 L3 统一高速缓存。</p><h3 id="高速缓存的读和写"><a href="#高速缓存的读和写" class="headerlink" title="高速缓存的读和写"></a>高速缓存的读和写</h3><p>略过把内存地址映射到快速缓存块的内容（这里不需要相关知识），高速缓存的读分为缓存命中和缓存不命中。</p><ul><li>对于缓存命中，即当程序需要读取 K + 1 层的某个数据时，当前 K 层的缓存已经存在，那么直接读取数据</li><li>而对于缓存不命中，即 K 层没有存储数据，那么将从 K + 1 层缓存读取数据，同时如果 K 层的缓存已经满了，可能需要覆盖现存的块。如通过 LRU 算法替换被访问时间距现在最远的块。</li></ul><p>而对于高速缓存的写则有两种方案</p><ul><li><p>直写（write through） + 非写分配（not write allocate）：</p><ul><li><p>直写：写命中时（即要写一个已经缓存的数据），同时写入缓存以及主内存</p></li><li><p>非写分配：写不命中时，不将写入位置读入缓存，直接将数据写入主内存</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/write_through.png" alt=""></p></li></ul></li><li><p>回写（write back） + 写分配（write allocate）：</p><ul><li><p>回写：写命中时，只写入缓存，只在数据被替换出缓存时才会将数据写到主内存</p></li><li><p>写分配：写不命中时，将写入位置读入缓存，然后以写命中的方式进行写入（即回写）</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/write_back.png" alt=""></p></li></ul></li></ul><p>有些（大多数是比较老的）CPU 只使用直写模式，有些只使用回写模式，还有一些，一级缓存使用直写而二级缓存使用回写。这样做虽然在一级和二级缓存之间产生了不必要的数据流量，但二级缓存和更低级缓存或内存之间依然保留了回写的优势。对于直写（write through），它需要一个写缓冲区（write buffer）将高速缓存写入的数据保存的主内存中</p><blockquote><i class="far fa-bell"></i> <p> &emsp;&emsp;写缓冲区的作用类似于异步处理来提高性能，比如当 CPU 的写入速度比缓存响应的还快时则减少了等待的时间，大大提高性能；同时它还能聚合多个写入到同一个缓存块从而减少下一级缓存的流量</p></blockquote><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>如果系统只有一个 CPU 核在工作，那么一些都没有问题。而如果一个 CPU 有多个核，且每个核都有自己的缓存，那么就会遇到问题：如果某个 CPU 缓存段中对应的内存内容被另外一个 CPU 改了，它无法感知到。而对于回写模式，写指令甚至会在执行过后很久才会真正写到 DRAM 中，这就造成了多组缓存不一致的问题。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;注意，这个问题的原因不在于多核而在于多组缓存。假如多个 CPU 核共用一组缓存，是不会存在这个问题的</p></blockquote><p>为了保证缓存一致性，MESI 协议就出现了。MESI 是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于只有四种状态：失效（Invalid）缓存段，共享（Shared）缓存段，独占（Exclusive）缓存段，已修改（Modified）缓存段。</p><blockquote><i class="far fa-bell"></i> <ul><li>失效（Invalid）缓存段: 要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。 </li><li>共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。</li><li>独占（Exclusive）缓存段，和 S 状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个 E 状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。</li><li>已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。</li></ul></blockquote><p>该协议保证：只有当缓存段处于 E 或 M 状态时处理器才能去修改它，也就是说只有这两种状态下，处理器是独占这个缓存段的。当处理器想写某个缓存段时，如果它没有独占权，它必须先发送一条“我要独占权”的请求给总线，这会通知其他处理器，把它们拥有的同一缓存段的拷贝失效。</p><p>而如果有其他处理器想读取这个缓存段，独占或已修改的缓存段必须先回到“共享”状态。如果是已修改的缓存段，那么还要先把内容回写到内存中。 </p><p>也就是说，<strong>MESI 保证一旦某个缓存段被回写修改后（M 状态），任意缓存级别的所有缓存段的内容和它对应的内存内容一致</strong></p><h3 id="写缓冲区和失效队列"><a href="#写缓冲区和失效队列" class="headerlink" title="写缓冲区和失效队列"></a>写缓冲区和失效队列</h3><p>缓存一致性已经能够保证对单个地址的读写的内存上的完整一致性，但是同步等待其他处理器指令返回影响了处理性能。<strong>因此在寄存器和 L1 缓存之间会有读写缓冲区（LoadBuffer,  StoreBuffer），合称排序缓冲（Memoryordering Buffers ，MOB ）。它们使得 CPU 异步处理读写指令，即当前处理器不需要等待其他处理器的失效确认（Invalidate Acknowlege）返回，会直接处理接下去的指令。</strong>  比如</p><ul><li>写指令：对于已处于 E（独占）状态的缓存行，CPU 会直接写入缓存行；而对于其他需要切换回 E 状态的情况，则首先向其他处理器发出失效指令，接着把要写入到主存的值写到 StoreBuffer，然后处理接下去指令。而 StoreBuffer 中的数据则等待失效确认（Invalidate Acknowlege）返回后统一刷新到内存。</li><li>读指令：对于处于 S（共享）状态的缓存行命中时，CPU 会直接读取缓存完成读指令；而对于其他状态需要切回 S 状态的情况，则会放入 LoadBuffer 中等待确认后处理</li></ul><p>但是这会导致一个严重的问题：</p><p>&emsp;&emsp;<em>即使读写指令本身是按照顺序执行的，但最终仍然存在指令重排序</em></p><p>比如按顺序执行 A, B 两个写指令，A 写指令所在缓存行处于 S 状态，B 写指令所在缓存行处于E状态，那么 B 会比 A 先完成写入操作；又或者按顺序执行 C, D 两个读指令，C 读指令所在缓存行处于 I 状态，D 读指令所在缓存行处于 S 状态，那么 D 会比 C 先完成读取操作。</p><p>同时处理器执行失效也不是一个简单的操作，它需要占用处理器的时间，如果接受的 invalidate 请求过多，cpu 处理速度就跟不上，因此又出现了失效队列（invalidate queue），它保证：</p><ul><li><p>对于所有的收到的 Invalidate 请求，Invalidate Acknowlege 消息必须立刻发送返回</p></li><li><p>Invalidate 并不真正执行，而是被放在一个失效队列中，在方便的时候才会去执行。</p><blockquote><p>当然，这里必须不能太慢。也就是说，cpu 实际上给出了一个承诺，如果一个 invalidatge 请求在 invalidate queue 中，那么对于这个请求相关的 cacheline，在该请求被处理完成前，cpu 不会再发送任何与该 cacheline 相关的 MESI 消息。 </p></blockquote></li></ul><p>同样这也会导致一个严重的问题：</p><p>&emsp;&emsp;<em>读取的时候有可能会读到过时的数据</em> </p><p>比如 CPU0 执行写指令，它向 CPU1 发出失效指令，然后 CPU1 立刻返回失效确认，但实际上并未真正执行失效操作。这时 CPU0 则更新了缓存行，造成了不同处理器直接的数据不一致。</p><p>所以我们现在可以总结下目前遇到的问题：</p><ul><li><strong>乱序处理器在满足 As-if-Serial 特性的基础下，本身就不会严格按照程序的顺序向缓存发送内存操作指令，导致指令重排序。</strong> </li><li><strong>Java 运行时环境的 JIT 编译器指令重排序</strong> </li><li><strong>由于 store buffer 和 invalidate queue 导致的内存可见性问题（即内存重排序）</strong> </li></ul><blockquote><p><i class="far fa-bell"></i> </p><p>&emsp;&emsp;As-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。比如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">double</span> pi  = <span class="hljs-number">3.14</span>;    <span class="hljs-comment">// A</span></span><br><span class="line"><span class="hljs-keyword">double</span> r   = <span class="hljs-number">1.0</span>;     <span class="hljs-comment">// B</span></span><br><span class="line"><span class="hljs-keyword">double</span> area = pi <em> r </em> r; <span class="hljs-comment">// C </span></span><br></pre></td></tr></table></figure><p>这里例子中，A 和 B 可以重排序，但是 A 和 C，B 和 C 不行，因为它们存在数据依赖关系。但需要注意的是，控制依赖仍然会存在重排序，比如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReorderExample</span> </span>&#123;</span><br><span class="line">​    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;</span><br><span class="line">​    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="hljs-number">1</span>;                   <span class="hljs-comment">//1</span></span><br><span class="line">        flag = <span class="hljs-keyword">true</span>;             <span class="hljs-comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function">Public <span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (flag) &#123;                <span class="hljs-comment">//3</span></span><br><span class="line">            <span class="hljs-keyword">int</span> i =  a * a;        <span class="hljs-comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来 3 和 4 存在控制依赖关系，不应该重排序，而实际上，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。这里 3 和 4 操作可能会被重排序为：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 先把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中</span></span><br><span class="line">temp = a * a;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(flag)&#123;</span><br><span class="line">​    <span class="hljs-comment">// 当flag为真后再赋值进去</span></span><br><span class="line">​    <span class="hljs-keyword">int</span> i = temp </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>那么它们会导致什么问题呢？我们以两个典型的案例来让问题显形：</p><ul><li><p>CPUB 依赖于 CPUA 发出的信号来执行逻辑</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DRAM: x = 0; y = false;</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  y = true;</span><br><span class="line"></span><br><span class="line">CPUB:</span><br><span class="line">  if(y)&#123;</span><br><span class="line">    assert x = 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个案例有可能会出现 CPUB 断言错误的情况，可能原因有以下几种</p><ul><li>由于指令重排序，CPUA 的两个写入指令重排序，导致 CPUB 读取到 y = true 时，x = 0</li><li>虽然指令未重排序，但由于 store buffer 的存在导致 CPUA 对 x = 1的指令写入主内存不及时使得 y = true 先被写入内存，那么 CPUB 就有可能读到老数据</li><li>虽然指令未重排序，但由于 invalidate queue 的存在导致虽然 Invalidate Acknowlege 返回后使得 store buffer 的数据已经回写到主存，但是由于失效消息未处理导致 CPUB 的缓存行仍有效，读到了老数据。</li></ul></li><li><p>CPUA，CPUB 互相读取对方的写入</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DRAM:</span><br><span class="line">  x, y, r1, r2 = 0</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  r1 = y;</span><br><span class="line">  </span><br><span class="line">CPUB：</span><br><span class="line">  y = 1;</span><br><span class="line">  r2 = x;</span><br></pre></td></tr></table></figure><p>和上述类似同样的原因，这个案例有可能会出现 r1 = r2 = 0 的情况。</p></li></ul><p>为了解决上述案例产生的问题，内存屏障诞生  =͟͟͞͞( •̀д•́)</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>JDK1.7 根据 store/load 指令的先后顺序将内存屏障分为以下四种：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/jdk-memory-barriers.png" alt=""></p><ul><li><p>LoadLoad 屏障</p><ul><li>防止 LoadLoad 屏障前后的读指令的指令重排序</li><li>处理器以阻塞的方式先处理失效队列的消息，防止读取到老数据</li></ul></li><li><p>StoreStore 屏障</p><ul><li>防止 StoreStore 屏障前后的写指令的指令重排序</li><li>处理器以阻塞的方式将当前存储缓存（store buffer）的值写回主存</li></ul></li><li><p>LoadStore 屏障</p><ul><li>防止 LoadStore 屏障前的读指令和屏障后的写指令的指令重排序</li><li>处理器以阻塞的方式先处理失效队列的消息，防止读取到老数据</li></ul><p>在 JVM 中，实际上它和 LoadLoad 屏障作用是相同的，底层都是调用 acquire() 方法</p></li><li><p>StoreLoad 屏障</p><ul><li><strong>防止 StoreLoad 屏障前后的所有读写指令的指令重排序</strong></li><li>处理器以阻塞的方式将当前存储缓存（store buffer）的值写回主存</li><li>处理器以阻塞的方式先处理失效队列的消息，防止读取到老数据</li></ul><p>该屏障同时具备另三种屏障的作用，因此开销也最大。</p></li></ul><p>它们并不是真正意义上的内存屏障，只是一种抽象的概念。在不同硬件中，内存屏障会有不同的实现。比如 x86 的 64 位 CPU 提供了 mfence, lfence, sfence 指令来提供内存屏障，而 x86 的 32 位 CPU 则不提供 mfence、lfence、sfence 三条汇编指令的支持。因此 Linux 内核定义 smp_mb, smp_rmb，smp_wmb 三种内存屏障来处理不同处理器架构（比如对于 X86-64 直接使用上述指令，而对于 X86-32 则通过 lock 前缀来实现）</p><h2 id="案例重现"><a href="#案例重现" class="headerlink" title="案例重现"></a>案例重现</h2><p>了解了内存屏障的作用后，我们重新再来分析之前的两个案例</p><ul><li><p>CPUB 依赖于 CPUA 发出的信号来执行逻辑</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DRAM: </span><br><span class="line">  x = 0; y = false;</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  StoreStore()</span><br><span class="line">  y = true;</span><br><span class="line"></span><br><span class="line">CPUB:</span><br><span class="line">  if(y)&#123;</span><br><span class="line">    LoadLoad()</span><br><span class="line">    assert x = 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们在 CPUA 和 CPUB 的程序中分别插入 StoreStore 屏障和 LoadLoad 屏障。它们能保证以下三点：</p><ul><li>CPUA 的写写指令，CPUB 的读读指令不能重排序</li><li>CPUA 写入 x 变量的值后保证将 store buffer 缓存的数据写回主内存。即写入 x 到主内存一定先于 y</li><li>CPUB 在读取到 y 的值后保证先处理 invalidate queue 的失效消息，即读取到 y 会重新从主内存获取最新的 x 的值</li></ul><p>那么这就保证一个顺序链：x 写入到主存 &lt; y 写入到主存 &lt; y 从主存读取数据 &lt; x 从主存读取数据。也就意味值：一旦 CPUB 读取到 y = true，x 的值总是等于 1</p></li><li><p>CPUA，CPUB 互相读取对方的写入</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DRAM:</span><br><span class="line">  x, y, r1, r2 = 0</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  StoreLoad();</span><br><span class="line">  r1 = y;</span><br><span class="line">  </span><br><span class="line">CPUB：</span><br><span class="line">  y = 1;</span><br><span class="line">  StoreLoad();</span><br><span class="line">  r2 = x;</span><br></pre></td></tr></table></figure><p>我们在 CPUA 和 CPUB 的程序中都插入了 StoreLoad 屏障。它们能保证以下三点：</p><ul><li><p>CPUA 和 CPUB 均不会对写入 x 和读取 y 两个操作重排序</p></li><li><p>CPUA 和 CPUB 写入值后保证将 store buffer 缓存的数据写回主内存</p></li><li>CPUA 和 CPUB 读取值之前保证先处理 invalidate queue，即总是读到主内存的最新数据</li></ul><p>那么我们可以推导出，当任一处理器执行到读取指令时，必定已经写入了当前值到主存且重新从主存读取数据，那么 r1 = r2 = 0 的情况也是不可能的了。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;该案例必须使用 StoreLoad 屏障。因为 CPUA 的读的值依赖于 CPUB 的写，而 CPUB 的读的值也依赖于 CPUA 的写，那么就需要同时保证写的及时性和读的正确性了。而每个处理器同时插入两条屏障（LoadLoad 屏障，StoreStore 屏障）也是不行的，因为它们都不能保证读写指令的重排序。</p></blockquote></li></ul><h2 id="volatile小解"><a href="#volatile小解" class="headerlink" title="volatile小解"></a>volatile小解</h2><p>JMM 通过内存屏障实现了 volatile 的内存语义，这里简单的讨论它的两点特性</p><p>&emsp;&emsp;<code>volatile 如何保证读取能读取到最新值？</code></p><p>仅从 CPU 层面来看，单个变量能够保证最终一致性的，即总能在一定时间内读取到最新值，因此不会存在读不到最新值的情况。但由于 Java 的 JIT 即时编译器的存在，会使得生成的汇编指令总是从寄存器暂存的数据获取值（甚至直接将值定义为常量），因此会有即使变量在主存更新了依然无法读取到变量的最新值的情况。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;寄存器不同于高速缓存，CPU 大多只能与寄存器交互（有些也可以和 L1 缓存交互，这里的高速缓存指的是无法直接交互的缓存），高速缓存的存在是因为 CPU 和主存交互太慢，需要缓存来提供性能。那么如果 CPU 始终从寄存器的暂存数据中读取，即使缓存是最终一致的，也会永远都不到最新值。</p></blockquote><p>而 volatile 的读基于 C++ 的 volatile 实现：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">inline</span> jint OrderAccess::load_acquire(<span class="hljs-keyword">volatile</span> jint* p) &#123; <span class="hljs-keyword">return</span> *p; &#125;</span><br></pre></td></tr></table></figure><p>它是一种编译器屏障，会禁止编译器优化，生成的加载指令不能从寄存器取值，而是总是从内存中加载（虽然由于高速缓存的存在，实际上总是从缓存加载），而因为缓存是最终一致的，因此可以保证可见性。</p><p>&emsp;&emsp;<code>volatile 如何保证写入最新值？</code></p><p>volatile 变量在写入后会插入 StoreLoad 屏障（lock 前缀的效果同 StoreLoad 屏障），即</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</span><br></pre></td></tr></table></figure><p>这样就保证了每次写入都会到主内存。</p><blockquote><i class="far fa-bell"></i> <ul><li><p>volatile 写之前会插入 StoreStore，防止和之前的任何写指令重排序</p></li><li><p>volatile 读之后会插入 LoadLoad，LoadStore 屏障，保证不和之后的读写指令重排序</p></li></ul><p>至于原因，可以参考之前的两个案例。实际上通过 volatile 关键字就能保证上述两个案例的并发正确性</p></blockquote><h2 id="Final小解"><a href="#Final小解" class="headerlink" title="Final小解"></a>Final小解</h2><p>JMM 同样通过内存屏障在一些情景下实现 final 的内存语义，这里也简单的讨论下</p><ul><li><p>初始读取共享对象与初始读取该共享对象的 final 成员变量之间不能重排序</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = sharedRef; </span><br><span class="line">... ; </span><br><span class="line">i = x.finalField;</span><br></pre></td></tr></table></figure><p>当存在数据依赖关系时，编译器本身不会对它们重排序。但确实有一些处理器会对这种情况进行重排序，因此特别制定了这一规则</p></li><li><p>如果在构造函数中有一条 final 字段的 store 指令，同时这个字段是一个引用，那么它将不能与构造函数外后续可以让持有这个 final 字段的对象被其他线程访问的指令重排。…代表构建方法边界</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ... ; sharedRef = x;</span><br><span class="line"></span><br><span class="line">v.afield = 1; x.finalField = v; ... ; sharedRef = x;</span><br></pre></td></tr></table></figure><p>JMM 为了满足 final 的这种特殊规则，实际上就是加了一个 StoreStore 屏障</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ... ; StoreStore() sharedRef = x;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">深入理解计算机系统(第三版)</a></li><li><a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="noopener">Cache (computing) Wiki</a>)</li><li><a href="https://www.cnblogs.com/jzssuanfa/p/7388066.html" target="_blank" rel="noopener">聊聊高并发（三十四）Java内存模型那些事（二）理解CPU快速缓存的工作原理</a></li><li><a href="http://witmax.cn/cache-writing-policies.html" target="_blank" rel="noopener">Cache写机制：Write-through与Write-back</a></li><li><a href="https://en.wikipedia.org/wiki/Write_buffer" target="_blank" rel="noopener">Write buffer Wiki</a></li><li><a href="https://stackoverflow.com/questions/33783862/why-we-use-write-buffer-in-mipscache" target="_blank" rel="noopener">why we use write buffer in mipscache?</a></li><li><a href="http://www.infoq.com/cn/articles/cache-coherency-primer" target="_blank" rel="noopener">缓存一致性（Cache Coherency）入门</a></li><li><a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">CPU缓存一致性协议MESI</a></li><li><a href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/" target="_blank" rel="noopener">Memory Barriers Are Like Source Control Operations</a></li><li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">linux-kernel-memory-barriers</a></li><li><a href="https://www.cnblogs.com/wewill/p/8098189.html" target="_blank" rel="noopener">内存屏障保证缓存一致性</a></li><li><a href="https://tech.meituan.com/java_memory_reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></li><li><a href="http://0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/" target="_blank" rel="noopener">聊聊原子变量、锁、内存屏障那点事</a></li><li><a href="https://www.cnblogs.com/icanth/archive/2012/06/10/2544300.html" target="_blank" rel="noopener">LINUX内核之内存屏障</a></li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></li><li><a href="https://www.jianshu.com/p/c6f190018db1" target="_blank" rel="noopener">指令重排序</a></li><li><a href="https://stackoverflow.com/questions/26307071/does-the-c-volatile-keyword-introduce-a-memory-fence" target="_blank" rel="noopener">Does the C++ volatile keyword introduce a memory fence?</a></li><li><a href="https://juejin.im/post/5ae9b41b518825670b33e6c4" target="_blank" rel="noopener">彻底理解volatile</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;现代计算机大多数采用多核处理器或多处理器以提高性能，同时每个处理器通常存在一层或多层高速缓存，这将会更进一步加快对数据的访问。但是这也带来了新的挑战，即同一数据在不同处理器之间并不保证一致。所以为了保证数据的可见性，内存屏障应运而生。它能够刷新或使本地处理器高速缓存失效，以便查看其他处理器进行的写入的最新值或使该处理器的写入对其他处理器可见。而 Java 内存模型用于屏蔽不同硬件所带来的内存访问差异，以实现程序在不同平台能保证一致的并发效果。那么在并发环境下如何正确的使用内存屏障成为了首要问题。&lt;/p&gt;
&lt;h2 id=&quot;硬件内存架构&quot;&gt;&lt;a href=&quot;#硬件内存架构&quot; class=&quot;headerlink&quot; title=&quot;硬件内存架构&quot;&gt;&lt;/a&gt;硬件内存架构&lt;/h2&gt;&lt;p&gt;Java 内存模型是对硬件内存模型的抽象，因此理解它需要一些硬件基础知识。这里主要介绍 &lt;strong&gt;处理器的存储器结构&lt;/strong&gt; 和 &lt;strong&gt;处理器的高速缓存与缓存一致性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;随机访问存储器（RAM）&quot;&gt;&lt;a href=&quot;#随机访问存储器（RAM）&quot; class=&quot;headerlink&quot; title=&quot;随机访问存储器（RAM）&quot;&gt;&lt;/a&gt;随机访问存储器（RAM）&lt;/h3&gt;&lt;p&gt;随机访问存储器（RAM），是用于和 CPU 交换数据的内部存储器。根据存储单元的工作原理不同可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态的存储器（DRAM）&lt;/li&gt;
&lt;li&gt;静态的存储器（SRAM）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SRAM 比 DRAM 更快，但也更贵，因此 SRAM 主要作为高速缓存存储器（Cache，如 CPU 的 L1，L2），而 DRAM 则作为计算机主存。而我们常说的内存指的就是是计算机的主内存 DRAM。&lt;/p&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="可见性" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
      <category term="内存屏障" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
</feed>
